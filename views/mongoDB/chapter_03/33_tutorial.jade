extends ../../layout
block content
    .container
        input#anchor(type='hidden' value='#{section}')
        ol.breadcrumb
            li
                a(href='/mongoDB') MongoDB
            li
                a(href='/mongoDB/crud') CRUD
            li.active 指导教程
        h3#section32 3.3 指导教程
        p 本页教程为MongoDB数据库的查询、更新、删除操作提供了指导性参考。
        ul
            li
                a(href='#section331') 3.3.1 插入文档
            li
                a(href='#section332') 3.3.2 查询文档
            li
                a(href='#section333') 3.3.3 指定查询语句返回的字段
            li
                a(href='#section334') 3.3.4 在mongo sheel中遍历指针
            li
                a(href='#section335') 3.3.5 分析查询语句的性能
            li
                a(href='#section336') 3.3.6 更新文档
            li
                a(href='#section337') 3.3.7 删除文档
            li
                a(href='#section338') 3.3.8 两阶段提交
            li
                a(href='#section339') 3.3.9 跟踪指针（Tailable Cursor）
            li
                a(href='#section3310') 3.3.10 操作的隔离
            li
                a(href='#section3311') 3.3.11 创建自增字段
            li
                a(href='#section3312') 3.3.12 更新数组后，限制数据元素的个数
        h4#section331 3.3.1 插入文档
        p 在MongoDB中，使用方法<code>db.collection.insert()</code>向集合添加文档。
        strong 插入单个文档
        p <strong><small>步骤1：向一个集合插入单个文档</small></strong>
        p 向一个名为<code>inventory</code>的集合插入一个文档。如果执行插入操作时，集合不存在，则插入操作自动创建该集合。
        .panel.panel-default
            .panel-heading 示例：插入单个文档
            .panel-body
                code db.inventory.insert(<br/>
                code &emsp;&emsp;{<br/>
                code &emsp;&emsp;&emsp;&emsp;item: "ABC1",<br/>
                code &emsp;&emsp;&emsp;&emsp;details: {<br/>
                code &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;model: "14Q3",<br/>
                code &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;manufacturer: "XYZ Company"<br/>
                code &emsp;&emsp;&emsp;&emsp;},<br/>
                code &emsp;&emsp;&emsp;&emsp;stock: [{size: "S", qty: 25}, {size: "M", qty: 50}],<br/>
                code &emsp;&emsp;&emsp;&emsp;category: "clothing"<br/>
                code &emsp;&emsp;}<br/>
                code )
        p 执行上述单文档插入操作后，会得到一个<code>WriteResult</code>对象，该对象指示了插入操作的结果状态。成功插入单个文档后，应返回如下结果：
        p
            code WriteResult({"nInserted" : 1})
        p <code>nInserted</code>字段标识成功插入的文档个数。如果插入操作发生异常，则<code>WriteResult</code>对象将包含异常信息。
        p <strong><small>步骤2：确认已插入文档</small></strong>
        p 如果步骤1中的插入操作成功返回，可以使用如下查询语句确认已插入的文档：
        p
            code db.inventory.find()
        p 上述查询语句将返回步骤1中插入的文档：
        p
            code { "_id" : ObjectId("54b87152eda88cd6fb3cfbb2"), "item" : "ABC1", "details" : { "model" :
                | "14Q3", "manufacturer" : "XYZ Company" }, "stock" : [ { "size" : "S", "qty" : 25 },
                | { "size" : "M", "qty" : 50} ], "category" : "clothing" }
        p 从上述返回结果中可以看出，MongoDB为新插入的文档自动生成了一个<code>_id</code>字段。如果客户端插入的文档不包含<code>_id</code>字段，
            | 则MongoDB自动为插入文档添加<code>_id</code>字段，并为该字段生成一个唯一<code>ObjectId</code>类型的值。
        strong 插入文档数组
        p 可以向方法<code>db.collection.insert()</code>传递一个文档数组，此时完成批量插入。
        p <strong><small>步骤1：创建一个文档数组</small></strong>
        p 定义一个名为<code>mydocuments</code>的变量，并将一个文档数组赋值给该变量
        .panel.panel-default
            .panel-heading 示例：声明文档数组
            .panel-body
                code var mydocuments =<br/>
                code(style='padding-left:20px;') [<br/>
                code(style='padding-left:40px;') {<br/>
                code(style='padding-left:60px;') item: "ABC2",<br/>
                code(style='padding-left:60px;') details: {model: "14Q3", manufacturer: "M1 Corporation"},<br/>
                code(style='padding-left:60px;') stock: [{size: "M", qty: 50}],<br/>
                code(style='padding-left:60px;') category: "clothing"<br/>
                code(style='padding-left:40px;') },<br/>
                code(style='padding-left:40px;') {<br/>
                code(style='padding-left:60px;') item: "MNO2",<br/>
                code(style='padding-left:60px;') details: {model: "14Q3", manufacturer: "ABC Company"},<br/>
                code(style='padding-left:60px;') stock: [{size: "S", qty: 5}, {size: "M", qty: 5}, {size: "L", qty: 1}],<br/>
                code(style='padding-left:60px;') category: "clothing"<br/>
                code(style='padding-left:40px;') },<br/>
                code(style='padding-left:40px;') {<br/>
                code(style='padding-left:60px;') item: "IJK2",<br/>
                code(style='padding-left:60px;') details: {model: "14Q2", manufacturer: "M5 Corporation"},<br/>
                code(style='padding-left:60px;') stock: [{size: "S", qty: 5}, {size: "L", qty: 1}],<br/>
                code(style='padding-left:60px;') category: "houseware"<br/>
                code(style='padding-left:40px;') }<br/>
                code(style='padding-left:20px;') ];
        p <strong><small>步骤2：插入数组</small></strong>
        p 将步骤1中声明的数组变量<code>mydocuments</code>传递给方法<code>db.collection.insert()</code>:
        p
            code db.inventory.insert(mydocuments);
        p 上述方法将返回一个<code>BulkWriteResult</code>对象，该对象指示了插入操作的结果状态，成功插入后，将返回如下所示的结果：
        code BulkWriteResult({<br/>
        code(style='padding-left:20px') "writeErrors": [],<br/>
        code(style='padding-left:20px') "writeConcernErrors": [],<br/>
        code(style='padding-left:20px') "nInserted": 3,<br/>
        code(style='padding-left:20px') "nUpserted": 0,<br/>
        code(style='padding-left:20px') "nMatched": 0,<br/>
        code(style='padding-left:20px') "nModified": 0,<br/>
        code(style='padding-left:20px') "nRemoved": 0,<br/>
        code(style='padding-left:20px') "upserted": []<br/>
        code })
        p <code>nInserted</code>字段标识成功插入的文档个数。如果插入操作发生异常，则<code>BulkWriteResult</code>对象将包含异常信息。
        p 上述插入的3个文档，MongoDB为各个文档添加了唯一的<code>_id</code>字段。
        strong 使用<code>Bulk</code>完成批量插入
        p 版本2.6的新特性
        p 除了使用<code>db.collection.insert()</code>方法完成批量插入，MongoDB还提供了<code>Bulk()</code>API。
            | 以下步骤详细介绍了如何使用<code>Bulk()</code>完成批量文档的插入操作。
        p <strong><small>步骤1：初始化<code>Bulk</code>操作构造器</small></strong>
        p 使用以下语法为集合<code>inventory</code>声明一个<code>Bulk</code>操作构造器：
        p
            code var bulk = db.inventory.initializeUnorderedBulkOp();
        p 上述语句返回一个集合相关的无序操作构造器，该构造器维护了一个将要被执行操作的列表。无序操作意味着MongoDB可以并行执行构造器中的操作，
            | 而不用关注执行操作的先后顺序。如果在执行过程中某个写操作发生异常，MongoDB将继续执行列表中的剩余操作。
        p 同样，可以使用方法<code>db.collection.initializeOrderedBulkOp()</code>声明一个有序操作构造器。
        p <strong><small>步骤2：将插入操作添加到<code>Bulk</code>操作构造器</small></strong>
        p 使用<code>Bulk.insert()</code>方法向变量<code>bulk</code>添加两个插入操作.
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                code bulk.insert(<br/>
                code(style='padding-left:20px;') {<br/>
                code(style='padding-left:40px;') item: "BE10",<br/>
                code(style='padding-left:40px;') details: { model: "14Q2", manufacturer: "XYZ Company" },<br/>
                code(style='padding-left:40px;') stock: [ { size: "L", qty: 5 } ],<br/>
                code(style='padding-left:40px;') category: "clothing"<br/>
                code(style='padding-left:20px;') }<br/>
                code );<br/>
                code bulk.insert(<br/>
                code(style='padding-left:20px;') {<br/>
                code(style='padding-left:40px;') item: "ZYT1",<br/>
                code(style='padding-left:40px;') details: { model: "14Q1", manufacturer: "ABC Company" },<br/>
                code(style='padding-left:40px;') stock: [ { size: "S", qty: 5 }, { size: "M", qty: 5 } ],<br/>
                code(style='padding-left:40px;') category: "houseware"<br/>
                code(style='padding-left:20px;') }<br/>
                code );<br/>
        p <strong><small>步骤3：执行Bulk操作构造器</small></strong>
        p 通过<code>bulk</code>对象的<code>execute()</code>方法执行构造器中的操作列表。
        p
            code bulk.execute();
        p 上述方法将返回一个<code>BulkWriteResult</code>对象，该对象指示了插入操作的结果状态，成功插入后，将返回如下所示的结果：
        code BulkWriteResult({<br/>
        code(style='padding-left:20px') "writeErrors": [],<br/>
        code(style='padding-left:20px') "writeConcernErrors": [],<br/>
        code(style='padding-left:20px') "nInserted": 2,<br/>
        code(style='padding-left:20px') "nUpserted": 0,<br/>
        code(style='padding-left:20px') "nMatched": 0,<br/>
        code(style='padding-left:20px') "nModified": 0,<br/>
        code(style='padding-left:20px') "nRemoved": 0,<br/>
        code(style='padding-left:20px') "upserted": []<br/>
        code })
        p <code>nInserted</code>字段标识成功插入的文档个数。如果插入操作发生异常，则<code>BulkWriteResult</code>对象将包含异常信息。
        strong 其他插入文档的方法
        p 方法<code>db.collection.update()</code>、方法<code>db.collection.findAndModify()</code>、方法<code>db.collection.save</code>
            | 同样可以完成文档插入操作，具体用法请参考相关API。
        h4#section332 3.3.2 查询文档
        p 在MongoDB中，方法<code>db.collection.find()</code>用于从集合中获取文档记录。方法<code>db.collection.find()</code>返回一个指向结果集的<code>指针（Cursor）</code>。
        .alert.alert-info
            p 方法<code>db.collection.findOne()</code>用于从集合中获取单个文档。在内部实现上，
                | 方法<code>db.collection.findOne()</code>是带有limit 1选项的<code>db.collection.find()</code>方法
        p 本教程描述了在<code>mongo</code>shell中使用<code>db.collection.find()</code>方法获取数据的方法。在这些示例中，
            | 结果集包含文档的所有字段。如果需要限制返回结果集中文档的字段，请参考<a href='#section333'>指定查询语句返回的字段</a>。
        strong 获取集合的所有文档
        p 使用空查询文档来获取集合中的所有文档记录：
        p
            code db.inventory.find({})
        p 在方法<code>db.collection.find()</code>中不指定参数，效果和指定一个空查询文档相同，所以，下述查询方法和上述查询方法是等效的：
        p
            code db.inventory.find()
        strong 指定相等过滤条件
        p 为了在查询语句中指定相等过滤条件，可以使用查询文档<code>{field : value}</code>，该查询文档获取集合中所有字段field的值等于value的的文档。
        p 下例中的查询语句从集合<code>inventory</code>中获取所有字段<code>type</code>的值为<code>snacks</code>的文档记录。
        p
            code db.inventory.find({type: "snacks"})
        strong 使用查询操作符指定查询条件
        p 在MongoDB的查询语句中，可以在查询文档中使用<em>查询操作符</em>来指定查询条件
        p 下例查询语句从集合<code>inventory</code>中获取所有满足查询条件的文档记录，查询条件为：文档<code>type</code>字段的值为<code>food</code>或<code>snacks</code>。
        p
            code db.inventory.find({type: {$in: ['food', 'snacks']}})
        p 虽然可以使用<code>$or</code>查询操作符完成功能上和上述查询语句等效的操作，但是在针对单个字段相等性判断时，通常使用操作符<code>$in</code>。
        strong 指定<code>AND</code>条件
        p 通常情况下，一个查询语句往往包含多个并列的查询条件。MongoDB隐式的将查询文档中的所有过滤条件使用逻辑与操作符连接起来，因此，
            | 结果集必须满足查询文档中的所有查询条件。
        p 在如下示例中，查询文档指定了<code>type</code>字段的相等条件，以及<code>price</code>字段的小于条件，
            | 必须同时满足这两个条件的文档会被筛选出来。
        p
            code db.inventory.find({type: 'food', price: {$lt: 9.95}})
        p 上述查询语句从集合<code>inventory</code>中获取所有满足<code>type</code>字段的值为<code>food</code>，
            | 并且<code>price</code>字段的值小于<code>9.95</code>这两个条件的文档。
        strong 指定<code>OR</code>条件
        p 使用<code>$or</code>操作符，可以指定逻辑或条件。即：只要满足查询条件中的至少一个就会被筛选出来。
        p 在如下示例中，查询语句从集合<code>inventory</code>中获取满足<code>qty</code>字段的值大于<code>100</code>，
            | 或者<code>price</code>字段的值小于9.95这两个条件中的一个的文档。
        p
            code db.inventory.find({$or: [{qty: {$gt: 100}}, {price: {$lt: 9.95}}]})
        strong 同时指定<code>AND</code>和<code>OR</code>条件
        p 如下查询语句必须同时满足以下两个查询条件：
        ul
            li 文档<code>type</code>字段的值为<code>food</code>
            li 文档<code>qty</code>字段的值大于<code>100</code>，或者字段<code>price</code>的值小于<code>9.95</code>
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                code db.inventory.find({<br/>
                code(style='padding-left:20px;') type: 'food'<br/>
                code(style='padding-left:20px;') $or: [{qty: {$gt: 100}}, {price: {$lt: 9.95}}]<br/>
                code })
        strong 嵌套文档
        p 当文档的一个字段持有一个嵌套文档时，查询语句可以精确完整匹配该嵌套文档，也可以通过<code>点符号（.）</code>匹配嵌套文档中的某些字段。
        p <strong><small>精确完整匹配嵌套文档</small></strong>
        p 为了指定嵌套文档的精确完整匹配，可以使用查询文档<code>{field : value}</code>， 其中，<code>value</code>代表需要匹配的嵌套文档。
            | 精确完整匹配时，不单单指嵌套文档的字段值，同样包含字段的顺序。
        p 如下示例中，查询语句从集合<code>inventory</code>中获取字段<code>producer</code>值为一个嵌套文档的文档记录，
            | 该嵌套文档包含值为<code>ABC123</code>的<code>company</code>字段，值为<code>123 street</code>的<code>address</code>字段，
            | 并且字段的顺序是：先<code>company</code>字段，后<code>address</code>字段。
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                code db.inventory.find({<br/>
                code.two producer:{<br/>
                code.third company: 'ABC123',<br/>
                code.third address: '123 Street'<br/>
                code.two }<br/>
                code })
        p <strong><small>匹配嵌套文档的某些字段</small></strong>
        p 可以使用<code>点符号（.）</code>来匹配嵌套文档的某些字段。嵌套文档指定字段的匹配指的是匹配文档必须包含指定值的指定字段，
            | 但是嵌套字段可以拥有其他额外的字段。
        p 如下示例中，查询语句从集合<code>inventory</code>中获取<code>producer</code>字段的嵌套文档包含一个值为<code>ABC123</code>的<code>company</code>字段的文档，
            | 同时，该嵌套文档可能包含<code>company</code>之外的其他字段。
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                code db.inventory.find({<br/>
                code.two 'producer.company': 'ABC123'<br/>
                code })
        strong 数组
        p 当文档中的一个字段持有一个数组类型时，可以精确匹配整个数组，也可以匹配数组中的指定元素。如果数组含有嵌套文档，
            | 可以使用上文提到的<code>点符号（.）</code>来匹配嵌套文档的指定字段。
        p 如果使用<code>$elemMatch</code>操作符指定了多个查询条件，则数组中必须包含至少一个元素满足所有的查询条件.
        p 如果没有使用<code>$elemMatch</code>操作符指定多个查询条件，则数组中的一些元素的组合必须满足所有的查询条件，
            | 即：不必是单个元素满足所有查询条件。也就是说：数组中的不同元素满足不同的查询条件，只要整体满足查询条件即可。
        p 下文中有关数组的查询语句使用如下的示例文档记录：
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                code { _id: 5, type: 'food', item: 'aaa', ratings: [5, 8, 9] }<br/>
                code { _id: 6, type: 'food', item: 'bbb', ratings: [5, 9] }<br/>
                code { _id: 7, type: 'food', item: 'ccc', ratings: [9, 5, 8] }
        p <strong><small>精确匹配数组</small></strong>
        p 可是用查询文档<code>{field : value}</code>精确完整匹配一个数组，其中，<code>value</code>是需要匹配的数组。
            | 精确完整匹配数组，不单单需要数组元素的匹配，也需要数组元素的顺序匹配。
        p 如下示例中，查询语句从集合<code>inventory</code>中获取字段<code>ratings</code>的值为<code>[5, 8, 9]</code>的文档，
            | 并且数组元素的顺序必须是<code>[5, 8, 9]</code>。
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                code db.inventory.find({<br/>
                code.two ratings: [5, 8, 9]<br/>
                code })
                p 上述查询语句的返回结果为：
                code { "_id" : 5, "type" : "food", "item" : "aaa", "ratings" : [ 5, 8, 9 ] }
        p <strong><small>匹配单个数组元素</small></strong>
        p 可以匹配数组中的某个元素，即：如果数组中包含至少一个指定元素则匹配成功。
        p 如下例所示，查询语句从集合<code>inventory</code>中获取<code>ratings</code>字段的数组包含元素<code>5</code>的文档。
        .panel.panel-default
            .panel-heading 实例
            .panel-body
                code db.inventory.find({ratings: 5})
                p 上述查询语句的返回结果为：
                code { _id: 5, type: 'food', item: 'aaa', ratings: [5, 8, 9] }<br/>
                code { _id: 6, type: 'food', item: 'bbb', ratings: [5, 9] }<br/>
                code { _id: 7, type: 'food', item: 'ccc', ratings: [9, 5, 8] }
        p <strong><small>匹配数组中指定位置的元素</small></strong>
        p 可以使用<code>点符号（.）</code>来准确匹配数组中指定位置的元素。
        p 如下例所示，查询语句从集合<code>inventory</code>中获取<code>ratings</code>字段的数组中第一个元素是<code>5</code>的文档。
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                code db.inventory.find({'ratings.0': 5})
                p 上述查询语句的返回结果为：
                code { _id: 5, type: 'food', item: 'aaa', ratings: [5, 8, 9] }<br/>
                code { _id: 6, type: 'food', item: 'bbb', ratings: [5, 9] }
        p <strong><small>数组元素满足多个查询条件</small></strong>
        ul
            li 数组的单个元素同时满足多个查询条件
                p 可以使用<code>$elemMatch</code>操作符指定多个查询条件，此时，数组中必须包含至少一个元素同时满足指定的多个查询条件。
                p 如下例所示，查询语句从<code>inventory</code>中获取<code>ratings</code>字段的数组中必须包含至少一个元素同时大于5小于9的文档。
                .panel.panel-default
                    .panel-heading 示例
                    .panel-body
                        code db.inventory.find({ratings: {$elemMatch: {$gt: 5, $lt: 9}}})
                        p 上述查询语句的返回结果为：
                        code { _id: 5, type: 'food', item: 'aaa', ratings: [5, 8, 9] }<br/>
                        code { _id: 7, type: 'food', item: 'ccc', ratings: [9, 5, 8] }
            li 数组的多个元素满足多个查询条件
                p 如下例所示，文档只要满足以下条件之一即可被匹配到：
                ul
                    li 数组中的某些元素大于5，并且数组中的某些元素小于9
                    li 数组中的某些元素同时满足大于5小于9的查询条件
                .panel.panel-default
                    .panel-heading 示例
                    .panel-body
                        code db.inventory.find({ratings: {$gt: 5, $lt: 9}})
                        p 上述查询语句的返回结果为：
                        code { _id: 5, type: 'food', item: 'aaa', ratings: [5, 8, 9] }<br/>
                        code { _id: 6, type: 'food', item: 'bbb', ratings: [5, 9] }<br/>
                        code { _id: 7, type: 'food', item: 'ccc', ratings: [9, 5, 8] }
                        p 结果中的第二个文档之所以被匹配到，是因为元素9大于5，并且5小于9.
        strong 嵌套文档数组
        p 假设集合<code>inventory</code>包含以下文档记录：
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                code {<br/>
                code.two _id: 100,<br/>
                code.two type: "food",<br/>
                code.two item: "xyz",<br/>
                code.two qty: 25,<br/>
                code.two price: 2.5,<br/>
                code.two ratings: [ 5, 8, 9 ],<br/>
                code.two memos: [ { memo: "on time", by: "shipping" }, { memo: "approved", by: "billing" } ]<br/>
                code }<br/>
                code {<br/>
                code.two _id: 101,<br/>
                code.two type: "fruit",<br/>
                code.two item: "jkl",<br/>
                code.two qty: 10,<br/>
                code.two price: 4.25,<br/>
                code.two ratings: [ 5, 9 ],<br/>
                code.two memos: [ { memo: "on time", by: "payment" }, { memo: "delayed", by: "shipping" } ]<br/>
                code }
        p <strong><small>使用数组下标匹配数组文档中的单个字段</small></strong>
        p 如果知道文档在数组中的下标，可以使用<code>点符号（.）</code>定位到嵌套的字段。
        p 如下例所示，查询语句从集合<code>inventory</code>中匹配文档，匹配文档的<code>memos</code>字段是一个数组，
            | 数组的第一个元素是一个嵌套文档，嵌套文档的<code>by</code>字段的值为<code>shipping</code>。
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                code db.inventory.find({'memos.0.by': 'shipping'})
                p 上述查询语句的结果为：
                code {<br/>
                code.two _id: 100,<br/>
                code.two type: "food",<br/>
                code.two item: "xyz",<br/>
                code.two qty: 25,<br/>
                code.two price: 2.5,<br/>
                code.two ratings: [ 5, 8, 9 ],<br/>
                code.two memos: [ { memo: "on time", by: "shipping" }, { memo: "approved", by: "billing" } ]<br/>
                code }<br/>
        p <strong><small>不使用数组下标匹配数组文档中的单个字段</small></strong>
        p 如果不知道嵌套文档在数组中的下标，可以将嵌套文档的字段名称使用<code>点符号（.）</code>连接到数组字段名后，用来匹配嵌套文档的指定字段。
        p 如下例所示，查询语句从集合<code>inventory</code>中匹配文档，匹配文档的<code>memos</code>字段是一个数组，
            | 数组中至少有一个嵌套文档的<code>by</code>字段的值为<code>shipping</code>。
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                code db.inventory.find({'memos.by': 'shipping'})
                p 上述查询语句的结果为：
                code {<br/>
                code.two _id: 100,<br/>
                code.two type: "food",<br/>
                code.two item: "xyz",<br/>
                code.two qty: 25,<br/>
                code.two price: 2.5,<br/>
                code.two ratings: [ 5, 8, 9 ],<br/>
                code.two memos: [ { memo: "on time", by: "shipping" }, { memo: "approved", by: "billing" } ]<br/>
                code }<br/>
                code {<br/>
                code.two _id: 101,<br/>
                code.two type: "fruit",<br/>
                code.two item: "jkl",<br/>
                code.two qty: 10,<br/>
                code.two price: 4.25,<br/>
                code.two ratings: [ 5, 9 ],<br/>
                code.two memos: [ { memo: "on time", by: "payment" }, { memo: "delayed", by: "shipping" } ]<br/>
                code }
        p <strong><small>数组嵌套文档的单个字段满足多个查询条件</small></strong>
        p 使用<code>$elemMatch</code>操作符指定多个查询条件时，此时，数组的嵌套文档中必须至少有一个嵌套文档满足所有的查询条件。
        p 如下例所示，查询语句从集合<code>inventory</code>中获取匹配文档，并且匹配到的嵌套文档必须满足字段<code>memo</code>的值为<code>on time</code>，
            | 字段<code>by</code>的值为<code>shipping</code>两个查询条件。
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                code db.inventory.find({<br/>
                code.two memos: {$elemMatch: {memo: 'on time', by: 'shipping'}}<br/>
                code })
                p 上述查询语句的结果为：
                code {<br/>
                code.two _id: 100,<br/>
                code.two type: "food",<br/>
                code.two item: "xyz",<br/>
                code.two qty: 25,<br/>
                code.two price: 2.5,<br/>
                code.two ratings: [ 5, 8, 9 ],<br/>
                code.two memos: [ { memo: "on time", by: "shipping" }, { memo: "approved", by: "billing" } ]<br/>
                code }<br/>
        p <strong><small>数组嵌套文档的多个字段满足多个查询条件</small></strong>
        p 如下例所示，查询语句从<code>inventory</code>中获取匹配文档，要求字段<code>memos</code>包含一个嵌套文档数组，
            | 并且嵌套文档必须满足以下查询条件之一：
        ul
            li 某个嵌套文档的<code>memo</code>字段的值为<code>on time</code>，另外某个嵌套文档的<code>by</code>字段的值为<code>shipping</code>
            li 某个嵌套文档的<code>memo</code>字段的值为<code>on time</code>，同时该文档的<code>by</code>字段的值为<code>shipping</code>
        p 并且，字段<code>memos</code>可以包含其他类型的元素。
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                code db.inventory.find({<br/>
                code.two 'memos.memo': 'on time',<br/>
                code.two 'memos.by': 'shipping'<br/>
                code })
                p 上述查询语句的结果为：
                code {<br/>
                code.two _id: 100,<br/>
                code.two type: "food",<br/>
                code.two item: "xyz",<br/>
                code.two qty: 25,<br/>
                code.two price: 2.5,<br/>
                code.two ratings: [ 5, 8, 9 ],<br/>
                code.two memos: [ { memo: "on time", by: "shipping" }, { memo: "approved", by: "billing" } ]<br/>
                code }<br/>
                code {<br/>
                code.two _id: 101,<br/>
                code.two type: "fruit",<br/>
                code.two item: "jkl",<br/>
                code.two qty: 10,<br/>
                code.two price: 4.25,<br/>
                code.two ratings: [ 5, 9 ],<br/>
                code.two memos: [ { memo: "on time", by: "payment" }, { memo: "delayed", by: "shipping" } ]<br/>
                code }
        h4#section333 3.3.3 指定查询语句返回的字段
        p 可以使用<em>投影</em>指定匹配到的文档返回哪些字段。投影可以指定需要返回哪些文档，或者指定不需要返回哪些字段。
        p 投影使用以下语法：
        table.table.table-bordered
            thead
                tr
                    th 语法
                    th 描述
            tbody
                tr
                    td field: 1 or true
                    td 指定需要返回的字段
                tr
                    td field: 0 or false
                    td 指定不需要返回的字段
        .alert.alert-danger 默认情况下，返回文档总是包含<code>_id</code>字段，如果不需要返回<code>_id</code>字段，
            | 则需要显式的指定投影操作：<code>_id: 0</code>。
        p 投影操作中，不能混合使用排除和包含操作，只有一个例外情况：针对<code>_id</code>字段的投影操作。
        p 本节内容详细介绍了如何限制返回结果文当集中的字段。本节的示例查询均是在<code>mongo</code> shell中使用方法<code>db.collection.find()</code>查询
             | 集合<code>inventory</code>。方法<code>db.collection.find()</code>返回一个指向查询结果集的<code>指针（Cursor）</code>。
        strong 返回查询结果集的所有字段
        p 如果在查询语句中没有指定投影操作，则<code>db.collection.find()</code>方法默认返回查询结果集的所有字段
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                code db.inventory.find({type: 'food'})
                p 上述查询语句返回集合<code>inventory</code>中所有字段<code>type</code>值为<code>food</code>的所有文档，
                    | 并且，返回匹配文档的所有字段。
        strong 只返回指定字段和<code>_id</code>字段
        p 可以使用投影操作显式的指定需要返回的字段。如下例所示，<code>find()</code>方法返回所有的匹配文档。在结果集中，
            | 只返回<code>item</code>和<code>qty</code>字段，默认情况下（没有显示的排除），<code>_id</code>字段也被包含在结果集中。
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                code db.inventory.find({type: 'food'}, {item: 1, qty: 1})
                p 上述查询语句返回集合<code>inventory</code>中所有字段<code>type</code>值为<code>food</code>的所有文档，
                    | 并且只返回匹配文档的<code>item</code>、<code>qty</code>和<code>_id</code>字段。
        strong 只返回指定字段
        p 如果不需要返回<code>_id</code>字段，需要显式的在投影操作中排除，如下所示：
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                code db.inventory.find({type: 'food'}, {item: 1, qty: 1, _id: 0})
                p 上述查询语句返回集合<code>inventory</code>中所有字段<code>type</code>值为<code>food</code>的所有文档，
                    | 并且只返回匹配文档的<code>item</code>和<code>qty</code>字段。
        strong 返回除排除字段以外的所有字段
        p 可以使用投影操作显式的指定不需要返回的单个字段或多个字段，如下所示：
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                code db.inventory.find({type: 'food'}, {type: 0})
                p 上述查询语句返回集合<code>inventory</code>中所有字段<code>type</code>值为<code>food</code>的所有文档，
                    | 并且除<code>type</code>字段外，返回匹配文档的其他所有字段。
        strong 数组字段的投影操作
        p 对于数组字段的投影操作，MongoDB提供了<code>$elemMatch、$slice、$</code>投影操作符。
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                p 假设集合<code>inventory</code>包含以下文档：<br/>
                    code {'_id': 5, 'type': 'food', 'item': 'aaa', 'ratings': [5, 8, 9]}
                p 如下例所示，查询语句使用<code>$slice</code>操作符只返回字段<code>ratings</code>数组的前两个元素：<br/>
                    code db.inventory.find({_id: 5}, {ratings: {$slice: 2}})
                p 只能使用操作符<code>$elemMatch、$slice、$</code>指定数组字段的投影操作，不能使用数组下标指定。即：
                    | <code>{'ratings.0': 1}</code>不能投影数组的第一个元素。
        h4#section334 3.3.4 在<code>mongo</code> shell中遍历指针
        p 方法<code>db.collection.find()</code>返回一直指向结果集的指针。为了获得结果集中的文档记录，需要遍历该指针。
            | 但是，在<code>mongo</code> shell中，如果没有将该指针赋值给一个使用<code>var</code>声明的变量，
            | 则自动取出该指针中的前20条记录，并将它们打印到控制台中。下文详述了如何手工遍历获得的指针以获取结果集中的文档，
            | 以及使用迭代器下标获取结果文档记录。
        strong 手工遍历结果集指针
        p 在<code>mongo</code> shell中，如果将<code>db.collection.find()</code>方法返回的结果集指针赋值给一个使用<code>var</code>声明的变量，
            | 则指针不会被自动遍历。
        p 以下几种方法详述了如何在<code>mongo</code> shell中手工遍历结果集指针：
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                ul
                    li 在<code>mongo</code> shell中输入指针变量，则自动获取指针变量的前20条记录，并将该20条记录打印到控制台中，代码如下：
                        p
                            code var myCursor = db.inventory.find({type: 'food'});
                            code myCursor
                    li 可以使用指针变量的<code>next()</code>方法获取文档记录：
                        p
                            code var myCursor = db.inventory.find({type: 'food'});<br/>
                            code while(myCursor.hasNext()) {<br/>
                            code.two print(tojson(myCursor.next()));<br/>
                            code }
                        p 可以使用方法<code>printjson()</code>代替方法<code>print(tojson())</code>。
                    li 可以使用指针变量的<code>forEach()</code>方法获取文档记录：
                        p
                            code var myCursor = db.inventory.find({type: 'food'});<br/>
                            code myCursor.forEach(printjson);
        strong 迭代器下标
        p 在<code>mongo</code> shell中，可以使用指针的<code>toArray()</code>方法完全遍历结果集，并将结果集保存在一个数组中，如下所示：
        p
            code var myCursor = db.inventory.find({type: 'food'});<br/>
            code var documentArray = myCursor.toArray();<br/>
            code var myDocument = documentArray[3];
        p 方法<code>toArray()</code>会将指针指向的文档全部加载到内存中，即：<code>toArray()</code>方法将指针消耗完毕。
        p 另外，一些驱动程序提供了使用指针下标获取文档的快捷方法（即：<code>cursor[index]</code>）。其实，这种方法仍然是调用了指针的<code>toArray()</code>方法，
            | 然后在<code>toArray()</code>方法返回的结果中使用下标获取结果文档记录。
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                p 如下所示：<br/>
                    code var myCursor = db.inventory.find({type: 'food'});<br/>
                    code var myDocument = myCursor[3];
                p 上述代码中的<code>var myDocument = myCursor[3];</code>其实等价于以下代码：<br/>
                    code var myDocument = myCursor.toArray()[3];
        h4#section335 3.3.5 分析查询语句的性能
        p 透过指针方法<code>explain()</code>，可以探测在MongoDB数据库内部，查询语句是如何执行的。
            | 可以使用该方法来分析查询语句的性能，以及用来查看查询语句使用索引的情况。可以使用方法<code>explain</code>来检测查询语句的行为，
            | 但是不能检测查询语句具体的查询性能如何。因为<code>explain()</code>方法针对查询语句会尝试多个查询计划，
            | 并不能准确的反映出查询语句的性能如何。
        .panel.panel-info
            .panel-heading 个人理解
            .panel-body <code>explain()</code>方法并不能反映出一个查询语句的性能如何，只是直观的列出查询语句在MongoDB数据库内容是如何运行的，
                | 查询语句性能的优劣必须是通过人为判断得出的，即：通过对比不同查询语句的<code>explain()</code>结果集。
        strong 评估查询语句的性能
        p 通过在<code>db.collection.find()</code>方法末尾添加指针方法<code>explain()</code>来得到对应的输出结果。
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                p 假设在集合<code>inventory</code>中，文档的<code>type</code>字段上存在一个索引，可以通过以下语句来评估针对<code>type</code>字段的查询。
                    code db.inventory.find({type: 'food'}).explain();
                p 上述语句的输出结果为：
                    code {<br/>
                    code.two "cursor" : "BtreeCursor type_1",<br/>
                    code.two "isMultiKey" : false,<br/>
                    code.two "n" : 5,<br/>
                    code.two "nscannedObjects" : 5,<br/>
                    code.two "nscanned" : 5,<br/>
                    code.two "nscannedObjectsAllPlans" : 5,<br/>
                    code.two "nscannedAllPlans" : 5,<br/>
                    code.two "scanAndOrder" : false,<br/>
                    code.two "indexOnly" : false,<br/>
                    code.two "nYields" : 0,<br/>
                    code.two "nChunkSkips" : 0,<br/>
                    code.two "millis" : 0,<br/>
                    code.two "indexBounds" : { "type" : [ [ "food", "food" ] ] },<br/>
                    code.two "server" : "mongodbo0.example.net:27017"<br/>
                    code }
                p 上述结果各个字段的解释如下：
                    ul
                        li <code>"cursor" : "BtreeCursor type_1"</code>表示该查询语句使用了索引。
                        li <code>"n" : 5</code>表示该查询语句最终返回5个文档。
                        li <code>"nscanned" : 5</code>表示为了获得最终的5个结果文档，查询语句需要从索引中遍历5个文档。
                        li <code>"nscannedObjects" : 5</code>表示查询语句从索引中获取5个文档后，需要从集合<code>inventory</code>中获取对应的5个文档（为了获取索引中不存在的字段值）。
                p 如果查询语句没有使用索引，则需要完全遍历集合<code>inventory</code>的记录以获取最终的5个文档。
        strong 比较索引的性能
        p 如果对于一个查询语句而言，存在多个可用的索引，可以通过使用<code>hint()</code>方法来比较各个索引的性能。
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                p
                    code db.inventory.find({type: 'food'}).hint({type: 1}).explain();<br/>
                    code db.inventory.find({type: 'food'}).hint({type: 1, name: 1}).explain()
                p 上述两个查询语句只会使用在<code>hint()</code>方法中指定的索引。
        .alert.alert-danger 如果在<code>explain()</code>方法前没有使用<code>hint()</code>方法，
            | 则查询优化器会重新为查询语句生成查询计划，并且尝试使用多个索引已返回查询语句的统计数据。
        h4#section336 3.3.6 更新文档
        p MongoDB提供了<code>update()</code>方法用于更新集合中的文档记录。该方法接收以下参数：
            ul
                li 更新条件文档，用于过滤需要更新的文档
                li 更新操作文档，用于指定具体的更新操作
                li 可选参数
        p 其中，<code>update()</code>方法的第一个参数：更新条件文档，该参数的语法和查询语句的语法相同。
        p 默认情况下，<code>update()</code>方法只更新单个文档，如果需要更新多个文档，需要在第三个参数中指定<code>multi</code>选项。
        strong 更新文档的指定字段
        p 为了更新文档的某个字段，MongoDB提供了各种<code>更新操作符</code>，比如用于修改字段值的<code>$set</code>更新操作符。
        p 对于一些更新操作符（比如：<code>$set</code>），如果目标文档不存在指定字段，则创建这些字段。
        p <strong><small>步骤1：使用更新操作符改变字段值</small></strong>
        p 如下例所示，从集合<code>inventory</code>中获取文档字段<code>item</code>值为<code>MNO2</code>的文档，
            | 使用<code>$set</code>更新操作符将字段<code>category</code>和<code>details</code>修改为指定值，
            | 并且使用<code>$currentDate</code>更新操作符将字段<code>lastModified</code>修改为当前时间。
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                code db.inventory.update(<br/>
                code.two {item: 'MNO2'},<br/>
                code.two {<br/>
                code.third $set: {<br/>
                code.fourth category: 'apparel',<br/>
                code.fourth details: {model: '14Q3', manufacturer: 'XYZ Company'}<br/>
                code.third },<br/>
                code.third $currentDate: {lastModified: true}<br/>
                code.two }<br/>
                code )
                p 上述更新语句返回一个<code>WriteResult</code>对象，该对象包含了更新语句的执行结果信息。
                    | 一个成功的更新语句返回如下所示的<code>WriteResult</code>对象：
                p
                    code WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })
                p 其中，字段<code>nMatched</code>字段标识该更新语句的过滤条件匹配到的文档数，
                    | <code>nModified</code>字段标识该更新语句更新的文档数。
        p <strong><small>步骤2：更新嵌套文档的字段</small></strong>
        p 可以使用<code>点符号（.）</code>更新文档中的嵌套文档的字段。当使用点符号时，必须将字段名至于引号中，如下例所示：
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                code db.inventory.update(<br/>
                code.two {item: 'ABC1'},<br/>
                code.two {$set: {'details.model': '14Q2'}}<br/>
                code )
                p 上述更新语句返回一个<code>WriteResult</code>对象，该对象包含了更新语句的执行结果信息。
                    | 一个成功的更新语句返回如下所示的<code>WriteResult</code>对象：
                p
                    code WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })
        p <strong><small>步骤3：更新多个文档</small></strong>
        p 默认情况下，<code>update()</code>方法更新单个文档。如果需要更新多个文档，可以在<code>update()</code>方法中添加<code>multi</code>选项。
        p 如下例所示：
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                code db.inventory.update(<br/>
                code.two {category: 'clothing'},<br/>
                code.two {<br/>
                code.third $set: {category: 'apparel'},<br/>
                code.third $currentDate: {lastModified: true}<br/>
                code.two },<br/>
                code.two {multi: true}<br/>
                code )
                p 上述更新语句返回一个<code>WriteResult</code>对象，该对象包含了更新语句的执行结果信息。
                    | 一个成功的更新语句返回如下所示的<code>WriteResult</code>对象：
                p
                    code WriteResult({ "nMatched" : 3, "nUpserted" : 0, "nModified" : 3 })
        strong 替换文档
        p 为了替换文档的除<code>_id</code>字段外的所有内容，可以向<code>update()</code>方法的第二个参数传递一个完整的文档记录。
        p 替换文档可以拥有与被替换文档不同的字段。在替换文档中，可以省略<code>_id</code>字段，因为该字段的值是不变的。
            | 如果在替换文档存在<code>_id</code>字段，则必须保证替换文档和被替换文档的<code>_id</code>字段值相同。
        p <strong><small>步骤1：替换一个已存在的文档</small></strong>
        p 如下例所示，更新语句将集合<code>inventory</code>中字段<code>item</code>值为<code>BE10</code>的第一个文档，
            | 替换为一个新文档，该新文档只包含<code>_id、item、stock、category</code>4个字段。
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                code db.inventory.update(<br/>
                code.two {item: 'BE10'},<br/>
                code.two {<br/>
                code.third item: 'BE05',<br/>
                code.third stock:[{size: 'S', qty: 20}, {size: 'M', qty: 5}],<br/>
                code.third category: 'apparel',<br/>
                code.two }<br/>
                code )
                p 上述更新语句返回一个<code>WriteResult</code>对象，该对象包含了更新语句的执行结果信息。
                    | 一个成功的更新语句返回如下所示的<code>WriteResult</code>对象：
                p
                    code WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })
        strong <code>upsert</code>选项
        p 默认情况下，方法<code>update()</code>如果没有匹配到任何文档，则该方法不会做任何操作。
        p 但是，通过为方法<code>update()</code>指定<code>upsert: true</code>选项，如果匹配到文档，则执行更新操作；
            | 如果没有匹配到文档，则执行插入操作。
        p <strong><small>步骤1：为替换文档的更新语句指定<code>upsert: true</code>选项</small></strong>
        p 当为一个替换文档更新语句（即：更新语句的更新操作文档部分为一个完整的文档对象）指定<code>upsert: true</code>选项时，
            | 如果没有匹配文档，则MongoDB首先使用更新条件文档中的相等条件创建一个新文档，然后使用更新操作文档替换新创建文档除<code>_id</code>字段外的其他所有字段。
        p 如下例所示，更新语句如果匹配到文档，则执行文档替换操作，如果没有匹配到文档，则执行插入操作。
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                code db.inventory.update(<br/>
                code.two { item: "TBD1" },<br/>
                code.two {<br/>
                code.third item: "TBD1",<br/>
                code.third details: { "model" : "14Q4", "manufacturer" : "ABC Company" },<br/>
                code.third stock: [ { "size" : "S", "qty" : 25 } ],<br/>
                code.third category: "houseware"<br/>
                code.two },<br/>
                code.two { upsert: true }<br/>
                code )
                p 上述更新语句如果成功返回，则返回一个如下所示的<code>WriteResult</code>对象：
                p
                    code WriteResult({<br/>
                    code.two "nMatched" : 0,<br/>
                    code.two "nUpserted" : 1,<br/>
                    code.two "nModified" : 0,<br/>
                    code.two "_id" : ObjectId("53dbd684babeaec6342ed6c7")<br/>
                    code })
                p 其中，各个字段的解释如下：
                    ul
                        li <code>nMatched</code>：更新语句匹配到的文档数
                        li <code>nUpserted</code>：更新语句插入的文档数
                        li <code>nModified</code>：更新语句更新的文档数
                        li <code>_id</code>：MongoDB为插入文档生成的<code>_id</code>字段的值
        p <strong><small>步骤2：为更新制定字段的更新语句指定<code>upsert: true</code>选项</small></strong>
        p 当为一个更新文档指定字段的更新语句指定<code>upsert: true</code>选项时，如果没有匹配到文档，则MongoDB首先使用更新条件文档中的相等条件创建一个新文档，
            | 然后使用更新操作文档部分更新新创建的文档。
        p 如下例所示，更新语句如果匹配到文档，则执行文档更新操作，如果没有匹配到文档，则执行插入操作。
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                code db.inventory.update(<br/>
                code.two { item: "TBD2" },<br/>
                code.two {<br/>
                code.third $set: {<br/>
                code.fourth details: { "model" : "14Q3", "manufacturer" : "IJK Co." },<br/>
                code.fourth category: "houseware"<br/>
                code.third }<br/>
                code.two },<br/>
                code.two { upsert: true }<br/>
                code )
                p 上述更新语句如果成功返回，则返回一个如下所示的<code>WriteResult</code>对象：
                p
                    code WriteResult({<br/>
                    code.two "nMatched" : 0,<br/>
                    code.two "nUpserted" : 1,<br/>
                    code.two "nModified" : 0,<br/>
                    code.two "_id" : ObjectId("53dbd684babeaec6342ed6c7")<br/>
                    code })
                p 其中，各个字段的解释如下：
                    ul
                        li <code>nMatched</code>：更新语句匹配到的文档数
                        li <code>nUpserted</code>：更新语句插入的文档数
                        li <code>nModified</code>：更新语句更新的文档数
                        li <code>_id</code>：MongoDB为插入文档生成的<code>_id</code>字段的值
        strong 其他更新文档的方法
        p 方法<code>db.collection.findAndModify()、db.collection.save</code>也可以完成更新已存在文档或插入新文档的功能。
        h4#section337 3.3.7 删除文档
        p 在MongoDB中，可以使用方法<code>db.collection.remove()</code>方法从一个集合中删除文档。
            | 可以从一个集合中删除所有文档、删除满足条件的文档、删除单个文档。
            | 本节内容详述了在<code>mongo</code> shell中使用方法<code>db.collection.remove()</code>删除文档的各种用法。
        strong 删除一个集合中的所有文档
        p 如果需要删除一个集合中的所有文档，可以向方法<code>db.collection.remove()</code>传递一个空文档（即：{}）参数。
            | <code>remove()</code>方法不会删除集合关联的索引。
        p 如下例所示，语句从集合<code>inventory</code>中删除所有文档：
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                code db.inventory.remove({});
                p 如果需要删除一个集合中的所有文档，更高效的方法是：在集合上调用方法<code>drop()</code>，以删除整个集合，
                    | 包括集合关联的索引，然后重建集合和相关索引。
        strong 删除满足条件的文档
        p 为了有条件的删除集合中的文档，可以在方法<code>update()</code>中指定删除条件，指定删除条件的语法和查询语句语法相同。
        p 如下例所示，语句删除集合<code>inventory</code>中所有<code>type</code>字段值为<code>food</code>的文档：
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                code db.inventory.remove({type: 'food'});
                p 对于大批量数据的删除操作，更高效的方法是：首先将集合中需要保留的文档拷贝到一个新的集合中，然后将原集合删除。
        strong 删除单个匹配文档
        p 为了删除单个文档，可以将方法<code>remove()</code>的第二个参数置为：<code>true</code>或<code>1</code>
        p 如下例所示，语句从集合<code>inventory</code>中删除单个满足<code>type</code>字段值为<code>food</code>条件的文档。
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                code db.inventory.remove({type: 'food'}, 1);
                p 如果需要删除某个按照指定顺序返回的文档，可以使用<code>findAndModify()</code>方法。
        h4#section338 3.3.8 两阶段提交
        strong 简介
        p 本节内容详述了如何使用两阶段提交模式来执行多文档更新操作，并且确保更新操作处于同一个事务中。另外，可以通过扩展该模式来实现一个类似回滚的操作。
        strong 背景
        p 在MongoDB中，单文档操作是原子性的；但是，涉及多文档的更新操作并不是原子性的。由于MongoDB的文档可以包含复杂的嵌套文档，
            | 结合单文档操作的原子性，对于某些情况，可以实现“多文档更新”的原子性。
        p 尽管可以通过结合单文档操作的原子性和嵌套文档来实现伪多文档操作，但是现实情况中却存在针对单独多个文档的更新操作，并且需要确保操作的原子性。
            | 当执行一个包含多个操作的事务时，可能存在以下问题：
            ul
                li 原子性：如果某个操作失败，则事务中的其他操作必须回滚到事务开始前的状态（即：该事务什么都不做）
                li 一致性：如果一个致命错误发生（比如：网络问题、硬件问题）在事务执行过程中，数据库必须有能力恢复到一个一致状态
        p 对于需要多文档操作的事务，可以在程序中实现两阶段提交操作提供事务支持。两阶段提交操作可以确保在一个事务中，如果发生错误，事务是可恢复的。
            | 但是，在两阶段提交过程中，文档数据可能是暂时有效的。
        .alert.alert-danger
            p 注意：在MongoDB中，只有单文档操作是原子性的，两阶段提交操作只能提供类似的事务处理，因此，应用程序可能读取到文档的中间状态值。
        strong 模式
        p <strong><small>概述</small></strong>
        p 考虑如下情景：将资金从账户A转移到账户B。在关系型数据库中，可以将从账户A转出资金和将资金转入账户B这两个操作置于单个事务中。
            | 在MongoDB中，可以通过两阶段提交操作模拟关系型数据库中的事务操作。
        p 对于上述两阶段提交操作的情景，需要用到如下两个集合：
            ul
                li 名为<code>accounts</code>的集合用于存储账户信息
                li 名为<code>transactions</code>的集合用于保存在两阶段提交操作过程中产生的相关信息
        p <strong><small>初始化源账户和目的账户信息</small></strong>
        p 向集合<code>accounts</code>插入账户A和账户B的信息
            .panel.panel-default
                .panel-heading 示例
                .panel-body
                    code db.accounts.insert([<br/>
                    code.two {_id: 'A', balance: 1000, pendingTransactions: []},<br/>
                    code.two {_id: 'B', balance: 1000, pendingTransactions: []}<br/>
                    code ])
        p <strong><small>初始化转账记录</small></strong>
        p 对于每个转账操作，需要向集合<code>transactions</code>中插入一条记录，用于保存该转账动作。并且转账记录应包含以下信息：
            ul
                li 字段<code>source、destination</code>，该两个字段关联到集合<code>accounts</code>的<code>_id</code>字段
                li 字段<code>value</code>，该字段用于指定本次转账的金额
                li 字段<code>state</code>，该字段标识转账动作的当前状态。可以包含以下状态值：<code>initial、pending、applied、done、canceling、canceled</code>
                li 字段<code>lastModified</code>字段，记录最后一次修改的时间（每次更改状态值时，都需要更新该字段）
        p 为了初始化从账户A转账100到账户B动作，需要向集合<code>transactions</code>插入如下记录：
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                code db.transactions.insert(<br/>
                code.two {_id: 1, source: 'A', destination: 'B', value: 100, state: 'initial', lastModified: new Date()}<br/>
                code )
        p <strong><small>使用两阶段提交完成转账操作</small></strong>
        dl
            dt 步骤1：获取需要处理的事务
            dd
                p 从集合<code>transaction</code>中获取一个<code>state</code>字段值为<code>initial</code>的文档。
                    | 如果按照上文步骤进行到此，此时集合中只有一个待处理的事务。如果集合中存在多个待处理事务，则需要限制查询语句的返回结果：
                p
                    code var t = db.transactions.findOne({state: 'initial'});
                p 上述查询语句将返回单个待处理事务：
                p
                    code { "_id" : 1, "source" : "A", "destination" : "B", "value" : 100, "state" : "initial", "lastModified" :... }

            dt 步骤2：更新事务状态为pending
            dd
                p 将上述事务记录的状态从<code>initial</code>更新为<code>pending</code>：
                p
                    code db.transactions.update({_id: t._id, state: 'initial'}, {$set: {state: 'pending'}, $currentDate: {lastModified: true}});
                p 上述更新语句中的<code>state: 'initial'</code>条件确保没有其他进程修改了该条记录。如果更新语句的返回结果中<code>nModified</code>的值为0，
                    | 即：没有更新任何记录，则结束当前操作，返回步骤1从新开始另外一个两阶段提交操作。
            dt 步骤3：将事务应用到两个账户
            dd
                p 如果该事务尚未被应用到对应文档时，使用<code>update()</code>方法将上文获取到的事务<code>t</code>应用到源账户和目的账户。
                    | 为了避免重复应用事务到对应文档，在<code>update()</code>方法的更新条件中添加过滤条件<code>pendingTransactions: {$ne: t._id}</code>。
                p 为了应用该事务到对应文档中，需要更新源账户和目的账户的<code>balance、pendingTransactions</code>两个字段。
                p 首先，更新源账户：
                p
                    code db.accounts.update({_id: t.source, pendingTransactions: {$ne: t._id}}, {$inc: {balance: -t.balance}, $push: {pendingTransactions: t._id}});
                p 然后，更新目的账户：
                p
                    code db.accounts.update({_id: t.destination, pendingTransactions: {$ne: t._id}}, {$inc: {balance: t.balance}, $push: {pendingTransactions: t._id}});
            dt 步骤4：更新事务状态为applied
            dd
                p 使用如下更新语句将对应事务的状态值更新为<code>applied</code>：
                p
                    code db.transactions.update({_id: t._id, state: 'pending'}, {$set: {state: 'applied'}, $currentDate: {lastModified: true}});
            dt 步骤5：更新账户的事务列表
            dd
                p 从源账户和目的账户的事务列表字段中移除状态值为<code>applied</code>的事务，如下：
                p
                    code db.accounts.update({_id: t.source, pendintTransactions: t._id}, {$pull: {pendingTransactions: t._id}});<br/>
                    code db.accounts.update({_id: t.destination, pendintTransactions: t._id}, {$pull: {pendingTransactions: t._id}});
            dt 步骤6：更新事务状态为done
            dd
                p 到此为止，该条事务执行完毕，需要将事务记录的状态值更新为<code>done</code>，如下所示：
                p
                    code db.transactions.update({_id: t._id, state: 'applied'}, {$set: {state: 'done'}, $currentDate: {lastModified: true}});
        strong 从失败场景中恢复
        p 关于多文档操作的事务处理，最重要的不是上文所述的执行过程，而是当事务失败时，如果从失败中恢复。本小节内容详述了在各阶段失败时如何恢复。
        p <strong><small>恢复操作</small></strong>
        p 上文中介绍的两阶段提交模式允许应用程序当失败产生时，可以恢复事务以使数据恢复到一致的状态。可以在应用程序启动时，或者定期去检测未完成事务，然后恢复未完成事务。
        p 将数据恢复到一致状态的耗时取决于应用程序需要多长时间恢复事务。
        p 如下示例中使用<code>lastModified</code>字段作为判断事务是否需要恢复的标识；即：如果一个<code>pending、applied</code>状态的事务，
            | 如果在过去的30分钟没有被更新，则该事务需要恢复。当然，根据实际情况，可以选择不同的判断标识。
        p <strong><small>恢复<code>pending</code>状态的事务</small></strong>&emsp;如果一个事务在<code>步骤2：更新事务事务状态为pending</code>之后，
            | 在<code>步骤4：更新事务状态为applied</code>之前失败，为了恢复该事务，首先从<code>transactions</code>中获取pending状态未完成的事务：
        p
            code var dateThreshold = new Date();<br/>
            code dateThreshold.setMinutes(dateThreshold.getMinutes() - 30);<br/>
            code var t = db.transactions.findOne({state: 'pending', lastModified: {$lt: dateThreshold}});
        p 获取未完成事务后，从<code>步骤3：将事务应用到两个账户</code>开始重新开始应用该事务。
        p <strong><small>恢复<code>applied</code>状态的事务</small></strong>&emsp;如果一个事务在<code>步骤4：更新事务事务状态为applied</code>之后，
            | 在<code>步骤6：更新事务状态为done</code>之前失败，为了恢复该事务，首先从<code>transactions</code>中获取applied状态未完成的事务：
        p
            code var dateThreshold = new Date();<br/>
            code dateThreshold.setMinutes(dateThreshold.getMinutes() - 30);<br/>
            code var t = db.transactions.findOne({state: 'applied', lastModified: {$lt: dateThreshold}});
        p 获取未完成事务后，从<code>步骤5：更新账户的事务列表</code>开始重新开始应用该事务。
        strong 回滚操作
        p 在有些场景中，可能需要回滚或取消一个事务；即：应用程序需要取消事务，或者应用程序检测到账户不存在时，需要取消事务。
        p <strong><small>回滚<code>applied</code>状态的事务</small></strong>&emsp;当事务执行完<code>步骤4：更新事务状态为applied</code>，
            | 此时，该事务不能被回滚。相反，必须按顺序执行完该事务，然后重启一个新事务，该新事务执行和原事务相反的操作。
        p <strong><small>回滚<code>pending</code>状态的事务</small></strong>&emsp;当事务执行完<code>步骤2：更新事务状态为pending</code>，
            | 可以按照如下步骤回滚事务：
            ul
                li 步骤1：更新事务状态为canceling
                    p 将事务状态从<code>pending</code>调整为<code>canceling</code>
                    p
                        code db.transactions.update({_id: t._id, state: 'pending'}, {$set: {state: 'canceling'}, $currentDate: {lastModified: true}});
                li 步骤2：取消两个账户的操作
                    p 为了取消事务中对两个账户的操作，需要反转原事务的操作。在更新语句的过滤条件中，需要包含条件<code>pendingTransactions: t._id</code>，
                        | 这样可以确保只反转已经更新账户的操作。
                    p
                        code db.accounts.update({_id: t.destination, pendingTransactions: t._id}, {$incr: {balance: -t.value}, $pull{pendingTransactions: t._id}});<br/>
                        code db.accounts.update({_id: t.source, pendingTransactions: t._id}, {$incr: {balance: t.value}, $pull{pendingTransactions: t._id}});
                li 步骤3：更新事务状态为canceled
                    p 为了标识已完成事务的回滚操作，需要将事务状态从<code>canceling</code>更改为<code>canceled</code>：
                    p
                        code db.transactions.update({_id: t._id, state: 'canceling'}, {$set: {state: 'canceled'}, $currentDate: {$lastModified: true}});
        strong 多应用程序
        p 由于事务的存在，多个应用程序可以并发的执行更新操作而不用担心数据的一致性或者操作的冲突。在上文的示例中，
            | 为了更新或者获取事务对象（transactions集合中的文档），过滤条件中始终包含<code>state</code>字段的判断，
            | 这样做是为了避免重复应用事务到关联文档。
        p 比如，应用程序<code>App1、App2</code>同时获取状态值为<code>initial</code>的事务。<code>App1</code>先于<code>App2</code>完成了整个事务，
            | 当<code>App2</code>尝试执行<code>步骤2：更新事务状态为pending</code>时，由于过滤条件<code>state: 'initial'</code>的存在，
            | 更新语句不会更新任何文档，即更新语句的返回结果中<code>nMatched、nModified</code>的值为0。此时，<code>App2</code>应该重新从<code>步骤1：获取需要处理的事务</code>开始，
            | 重新执行一个不同的事务。
        p 当多个应用程序同时运行时，必须确保在任何时间点只有单个应用程序在处理指定的单个事务。所以，为了标识事务是属于哪个应用程序的，
            | 除了在事务文档中指定<code>state</code>字段，还需要添加一个标识应用程序的字段<code>application</code>，
            | 可以使用<code>findAndModify()</code>方法完成获取和更改操作：
        p
            code t = db.transactions.findAndModify(<br/>
            code.two {<br/>
            code.third query: { state: "initial", application: { $exists: false } },<br/>
            code.third update:{<br/>
            code.fourth $set: { state: "pending", application: "App1" },<br/>
            code.fourth $currentDate: { lastModified: true }<br/>
            code.third },<br/>
            code.third new: true<br/>
            code.two }<br/>
            code )
        p 如果<code>App1</code>在事务执行过程中出现异常，可以参考上文的<em>恢复操作</em>执行后续操作。但是，应用程序必须确保：
            | 应用程序只会执行属于自己的事务，如下所示：
        p
            code var dateThreshold = new Date();<br/>
            code dateThreshold.setMinutes(dateThreshold.getMinutes() - 30);<br/>
            code db.transactions.find(<br/>
            code.two {<br/>
            code.third application: "App1",<br/>
            code.third state: "pending",<br/>
            code.third lastModified: { $lt: dateThreshold }<br/>
            code.two }<br/>
            code )
        strong 在生产环境中使用两阶段提交操作
        p 上文介绍的有关两阶段提交操作的示例是非常简单的。比如：上例中的转账操作假设账户可以接受负值。
        p 对于所有的事务操作，请确保部署的MongoDB数据库已经配置了适合的<em>写关注（write concern）</em>。
        h4#section339 3.3.9 跟踪指针（Tailable Cursor）
        strong 简介
        p 默认情况下，MongoDB在客户端消耗完一个指针后会自动关闭该指针。但是，对于<em>capped collection</em>，可以使用<em>跟踪指针</em>，
            | 当客户端消耗完跟踪指针中初始数据后，跟踪指针仍然保持打开状态。跟踪指针在概念上等同于Unix系统中的<code>tail -f</code>命令。
            | 当客户端向capped collection插入一个新文档后，跟踪指针会继续获取到新插入的文档。
        p 当一个没有capped collection拥有大量的写入操作，但是没有关联索引时，可以考虑使用跟踪指针。比如，
            | MongoDB的复制操作使用跟踪指针用于跟踪primary的oplog。
        .alert.alert-danger 如果查询语句查询的字段上存在索引，不要使用跟踪指针，需要使用普通的指针。跟踪查询语句返回的最后一个索引字段的值，
            | 为了获取新插入的文档，可以使用如下语句:<br/>
            | db.collection.find({indexedField: {$gt: lastValue}});<br/>
            | 上述语句利用了索引是有序的特性。
        p 跟踪指针拥有以下行为：
            ul
                li 跟踪指针不会使用索引，并且按照文档的插入顺序返回
                li 由于跟踪指针不会使用索引，所以初始查询的代价可能较高；但是，一旦跟踪指针开始返回数据，后续的结果返回的代价并不高。
                li 如果出现以下情况，跟踪指针可能会变得不可用：
                    ul
                        li 查询语句没有结果需要返回
                        li 跟踪指针已返回集合中的数据，但是接着应用程序删除了集合中的剩余文档
            p 如果一个跟踪指针变得不可用，此时，该跟踪指针的id为0；
        p 对于具体的使用细节，请参考对应的驱动文档。
        h4#section3310 3.3.10 操作的隔离
        strong 简介
        p 在MongoDB中，只有针对单文档的写操作是原子性的，即：一个写操作只能原子性的操作单个文档，不能原子性的操作多个文档。
        p 当一个写操作影响多个文档时，整个写操作不是原子性的，其他的操作可能插入到该写操作的执行过程中。针对单文档的写操作永远是原子性的，
            | 即便该写操作更改了单文档中的多个嵌套文档。
        p 虽然MongoDB中只有单文档的写操作是原子性的，但是，可以通过使用<coode>隔离操作符</code>将一个影响多个文档的写操作隔离起来。
        p 本节内容介绍了一种隔离操作的方法：首先获取需要更新的文档，更新时如果开始获取的文档和当前文档的状态一直，此时才能执行更新操作
            | （类似于关系数据库中的乐观锁机制）。除了该种方法外，如下方法也能够提供操作的隔离：
            ul
                li 使用<code>findAndModify()</code>方法实现查询和更新操作的原子性
                li 使用上文介绍的两阶段提交模式
                li 通过<em>唯一性索引</em>实现键值的唯一性
        strong 只有在文档没有发生改变的情况下更新文档（类似关系数据库中的乐观锁机制）
        p 在该模式中，需要进行如下操作：
            ul
                li 查询一个文档
                li 根据需要修改文档的指定字段
                li 更新文档（只有在文档字段没有被其他用户修改的情况下）
        .panel.panel-default
            .panel-heading 示例
            .panel-body
            code var myCollection = db.products;<br/>
            code var myDocument = myCollection.findOne( { sku: 'abc123' } );<br/>
            code if (myDocument) {<br/>
            code.two var oldQty = myDocument.qty;<br/>
            code.two if (myDocument.qty < 10) {<br/>
            code.third myDocument.qty *= 4;<br/>
            code.two } else if ( myDocument.qty < 20 ) {<br/>
            code.third myDocument.qty *= 3;<br/>
            code.two } else {<br/>
            code.third myDocument.qty *= 2;<br/>
            code.two }<br/>
            code.two var results = myCollection.update(<br/>
            code.third {<br/>
            code.fourth _id: myDocument._id,<br/>
            code.fourth qty: oldQty<br/>
            code.third },<br/>
            code.third {<br/>
            code.fourth $set: { qty: myDocument.qty }<br/>
            code.third }<br/>
            code.two );<br/>
            code.two if ( results.hasWriteError() ) {<br/>
            code.fourth print("unexpected error updating document: " + tojson( results ));<br/>
            code.two } else if ( results.nMatched == 0 ) {<br/>
            code.fourth print("No update: no matching document for { _id: " + myDocument._id + ", qty: " + oldQty }<br/>
            code }
        p 对于上述模式的实际使用，可能需要作出以下调整：
            ul
                li 在<code>update()</code>方法中，将原始文档的所有字段作为过滤条件，以确保原始文档的所有字段都没有发生改变
                li 在文档中添加一个版本号字段，应用程序维护该字段的值，每次更新操作都会将该字段加1，然后再<code>update()</code>方法中使用该版本号字段作为过滤条件
                li 只更改需要更改的字段，确保更新操作不会影响文档其他字段的值
                li 使用<a href='#section3311'>3.3.11 创建自增字段</a>中介绍的方法
        h4#section3311 3.3.11 创建自增字段
        strong 简介
        p MongoDB保证所有文档拥有一个<code>_id</code>主键，<code>_id</code>必须是唯一的，并且拥有相关联的唯一性索引。但是，
            | 处理通过唯一索引来达到<code>_id</code>字段值的唯一性，本文介绍了如下两种方法用于为<code>_id</code>字段生成序列：
            ul
                li 使用Counters集合
                li 乐观循环
        strong 说明
        p 在MongoDB中，通常情况下，并不需要为<code>_id</code>字段或其他字段生成自增长的序列，因为这样做并不会大规模的降低数据库的大小，
            | 并且并不是所有字段都适合自增长的序列。通常来讲，<code>_id</code>字段的默认值（<em>ObjectId</em>）是非常合适的。
        strong 实现方法
        p <strong><small>使用Counters集合</small></strong>
        p <strong><small>实现Counters集合</small></strong>&emsp;使用一个独立的<code>counters</code>集合用于跟踪最后一个序列号。
            | <code>_id</code>字段记录序列的名称，<code>seq</code>字段记录序列值。
            ol
                li 向集合<code>counters</code>插入需要生成的序列：
                    p
                        code db.counters.insert({_id: 'userid', seq: 0});
                li 创建<code>getNextSequence()</code>方法：
                    p
                        code function getNextSequence(name) {<br/>
                        code.two var ret = db.counters.findAndModify(<br/>
                        code.third {<br/>
                        code.fourth query: {_id: name},<br/>
                        code.fourth update: {$inc: {seq: 1}},<br/>
                        code.fourth new: true<br/>
                        code.third }<br/>
                        code.two );<br/>
                        code.two return ret.seq;<br/>
                        code }
                li 在<code>insert()</code>方法中使用<code>getNextSequence(name)</code>方法：
                    p
                        code db.users.insert(<br/>
                        code.two {<br/>
                        code.third _id: getNextSequence("userid"),<br/>
                        code.third name: "Sarah C."<br/>
                        code.two }<br/>
                        code )<br/><br/>
                        code db.users.insert(<br/>
                        code.two {<br/>
                        code.third _id: getNextSequence("userid"),<br/>
                        code.third name: "Sarah C."<br/>
                        code.two }<br/>
                        code )
                    p 结果为：
                        code {<br/>
                        code.two _id : 1,<br/>
                        code.two name : "Sarah C."<br/>
                        code }<br/>
                        code {<br/>
                        code.two _id : 2,<br/>
                        code.two name : "Bob D."<br/>
                        code }
        p <strong>findAndModify()方法的行为特点<small></small></strong>&emsp;
        p <strong><small>乐观循环</small></strong>



