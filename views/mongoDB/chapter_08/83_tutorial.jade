extends ../../layout
block content
    .container
        input#anchor(type='hidden' value='#{section}')
        ol.breadcrumb
            li
                a(href='/mongoDB') MongoDB
            li
                a(href='/mongoDB/index') 索引
            li.active 指导教程
        h3 8.3&emsp;指导教程
        p 索引通过高效的存储结构存储集合文档的部分数据，允许MongoDB高效的执行相关查询语句。
        p 本节内容详细介绍了在MongoDB中创建索引、维护索引相关的内容，并且讨论了索引的实施策略和实际使用。
        p 本节主要包含以下内容：
        ul
            li
                a(href='#section831') 8.3.1&emsp;创建索引
            li
                a(href='#section832') 8.3.2&emsp;管理索引
            li
                a(href='#section833') 8.3.3&emsp;空间索引
            li
                a(href='#section834') 8.3.4&emsp;文本搜索索引
            li
                a(href='#section835') 8.3.5&emsp;索引策略
        h4#section831 8.3.1&emsp;创建索引
        p 以下内容详细讲解了在MongoDB中如何创建各种类型的索引，以及在副本级、分片群集中如何创建索引。
        strong 在单个字段上创建索引
        p 可以使用方法<code>ensureIndex()</code>或者驱动程序中的API方法创建索引。方法<code>ensureIndex()</code>只有在索引不存在时创建，
            | 即：该方法不会重复创建索引。
        p 例如，下例操作在集合<code>records</code>的字段<code>userid</code>上创建了一个普通索引：
        p
            code db.records.ensureIndex({userid: 1})
        p 使用<code>ensureIndex()</code>方法创建索引时，为索引字段指定的值（上例中为：1）代表创建的索引类型。例如：
            | <code>1</code>代表索引以升序存储；<code>-1</code>代表索引以降序存储。
        p 上述语句创建的索引会加速字段<code>userid</code>上的查询，例如：
        p
            code db.records.find({userid: 2})<br/>
            code db.records.find({userid: {$gt: 10}})
        p 上述语句创建的索引对于<code>userid</code>字段之外字段的查询没有效果（即：其他字段的查询不会使用该索引），例如：
        p
            code db.records.find({profile_url: 2})
        p 对于不能使用索引的查询语句，MongoDB必须遍历集合中的所有文档，以获得匹配查询条件的文档集合。
        p
            strong
                small 其他考虑
        p 虽然索引可以提高查询语句的执行效率，但是索引本身仍然需要耗费存储空间，并且，对于文档的更新操作，不单单需要更新集合数据，
            | 仍然需要更新关联的索引数据，所以，在创建索引之前，应该全面的考虑索引策略。
        p 如果集合包含大量的数据，并且要求在索引创建过程中，对该集合仍然可以正常访问，可以考虑使用在后台创建索引。
        strong 创建复合索引
        p 可以使用类似下例的方法创建复合索引（即：索引字段为多个）：
        p
            code db.collections.ensureIndex({a: 1, b: 1, c: 1})
        p 使用<code>ensureIndex()</code>方法创建索引时，为索引字段指定的值（上例中为：1）代表创建的索引类型。例如：
            | <code>1</code>代表索引以升序存储；<code>-1</code>代表索引以降序存储。
        p
            strong
                small 示例
        p 如下操作在集合<code>products</code>的字段<code>item、category、price</code>上创建了一个符合索引：
        p
            code db.products.ensureIndex({item: 1, category: 1, price: 1})
        p
            strong
                small 其他考虑
        p 虽然索引可以提高查询语句的执行效率，但是索引本身仍然需要耗费存储空间，并且，对于文档的更新操作，不单单需要更新集合数据，
            | 仍然需要更新关联的索引数据，所以，在创建索引之前，应该全面的考虑索引策略。
        p 如果集合包含大量的数据，并且要求在索引创建过程中，对该集合仍然可以正常访问，可以考虑使用在后台创建索引。
        strong 创建唯一性索引
        p MongoDB允许为索引指定唯一性约束，唯一性约束会阻止应用程序插入索引字段值重复的文档。另外，如果需要在已存在重复值的字段上创建唯一性索引，
            | 创建索引时，需要执行重复数据的删除操作。
        p 使用类似下例的语法创建唯一性索引（即：需要指定<code>unique: true</code>选项）：
        p
            code db.collection.ensureIndex({a: 1}, {unique: true})
        p 例如，需要在集合<code>accounts</code>的字段<code>tax-id</code>上创建唯一性索引，以保证该字段不会存在重复值，可以使用如下语句：
        p
            code db.accounts.ensureIndex({'tax-id': 1}, {unique: true})
        p 默认情况下，集合的<code>_id</code>字段上的索引是唯一性索引。在某些场景种，可能使用该字段作为业务相关的唯一性限制，
            | 而不是在单独的字段上创建唯一性索引。
        p 在某些场景中，可能会将唯一性约束和稀疏选项结合使用。当MongoDB在某个字段上创建索引时，如果文档的对应字段为空，则唯一性索引中针对该文档的索引条目为<code>null</code>，
            | 由于唯一性索引不允许存在重复值，通过使用稀疏选项，如果后续文档没有索引字段或者字段值为空，则索引不会存在文档的索引条目，使用方法如下：
        p
            code db.collection.ensureIndex({a: 1}, {unique: true, sparse: true})
        p 同样，唯一性约束也可以用于复合索引：
        p
            code db.collection.ensureIndex({a: 1, b: 1}, {unique: true})
        p 复合索引的唯一性约束指的是索引字段组合的唯一，而不是各个字段都需要唯一。
        p
            strong
                small 删除重复值
        p 如果必须在已包含重复值的字段上创建索引，可以使用<code>dropDups</code>选项，该选项会在创建索引过程中，删除后续的重复记录，如下：
        p
            code db.collection.ensureIndex({a: 1}, {unique: true, dropDups: true})
        .alert.alert-danger 指定<code>dropDups: true</code>选项会导致集合数据丢失，必须谨慎使用。
        strong 创建稀疏索引
        p 稀疏索引和非稀疏索引类似，不同点是：稀疏索引对于不包含索引字段（或字段为空）的文档，并不存储索引条目。因此，稀疏索引在某些场景种，
            | 可以节省存储空间。
        p 可以使用类似下例的语法创建稀疏索引：
        p
            code db.collection.ensureIndex({a: 1}, {sparse: true})
        p
            strong
                small 示例
        p 如下语句在集合<code>users</code>的<code>twitter_name</code>字段上创建一个稀疏索引：
        p
            code db.users.ensureIndex({'twitter_name': 1}, {sparse: true})
        p 上述索引中不包含不存在索引字段<code>twitter_name</code>的文档的索引条目。
        p
            strong
                small 其他考虑
        p 有时稀疏索引不能返回完整的结果集，此时查询语句不会使用该稀疏索引。
        strong 创建哈希索引（版本2.4新特性）
        p 哈希索引首先对索引字段的值计算哈希值，然后对哈希值建立索引。哈希索引支持相等性匹配，并且对于一些分片集合很适合作为分片键。
        .alert.alert-info 当建立哈希索引时，哈希值的计算是由MongoDB自动完成的，不需要应用程序计算。
        p 可是使用类似下例的语法创建哈希索引：
        p
            code db.collection.ensureIndex({_id: 'hashed'})
        p
            strong
                small 其他考虑
        p MongoDB支持任意字段的哈希索引，但是不支持数组字段。
        p 如果一个字段上已经存在哈希索引，则不能在该字段上创建复合索引。
        strong 在副本集上创建索引
        p 在副本集中，当一级成员完成索引的创建后，二级成员才开始创建索引。在分片群集中，
            | <code>mongos</code>会将<code>ensureIndex()</code>发送到每个分片（分片为副本集）的一级成员，
            | 一级成员完成索引的创建后，二级成员开始创建对应的索引。
        p 为了最小化索引创建对副本集的影响，请使用下文介绍的处理步骤创建索引。
        p
            strong
                small 处理步骤
        .alert.alert-info 如果是在分片集群（每个分片都是副本集）上创建索引，则在每个分片上重复以下步骤即可。
        ul
            li
                strong 停止一个二级成员
                p 停止一个二级成员的<code>mongod</code>实例，然后不使用选项<code>--replSet</code>在不同的端口重启该<code>mongod</code>实例。
                    | 此时，该实例处于“独立”模式。
                p 例如，如果二级成员的<code>mongod</code>实例是在27017端口运行，可以不使用选项<code>--replSet</code>在端口47017重启该实例，如下：
                p
                    code mongod --port 47017
            li
                strong 创建索引
                p 在<code>mongo</code> shell中使用方法<code>ensureIndex()</code>创建索引。
                p 例如，在集合<code>records</code>的<code>username</code>字段上创建一个升序索引：
                p
                    code db.records.ensureIndex({username: 1})
            li
                strong 重启mongod实例
                p 当索引创建成功后，使用选项<code>--repsSet</code>在原来的端口下重启<code>mongod</code>实例：
                p
                    code mongod --port 27017 --respSet rs0
                p 上述命令使实例重新加入原来的副本集中。
            li
                strong 在所有二级成员上创建索引
                p 对于副本集中的所有二级成员，按照上述三个步骤完成各自索引的创建。
            li
                strong 在一级成员上创建索引
                p 对于一级成员上的索引创建，可以采用以下两种方法中的任意一种：
                ol
                    li 在一级成员上执行后台创建索引
                    li 在<code>mongo</code> shell中使用方法<code>rs.stepDown()</code>停止一级成员，
                        | 该操作会使当前的一级成员成为二级成员，副本集会通过选举产生一个新的一级成员。
                        | 之后按照上文介绍的三个步骤完成索引的创建。
        p 后台创建索引比前台创建索引耗时更长，并且导致一个不太紧凑的索引结构；另外，后台创建索引可能影响一级成员的些操作的性能。
            | 但是，后台创建索引允许副本集在索引创建过程中持续的提供正常的服务。
        p
            strong
                small 其他考虑
        ul
            li 确保<code>oplog</code>足够大，以使副本集成员在完成创建索引操作后，成员实例的状态不会落下太远，通过<code>oplog</code>可以赶上。
            li 上述处理步骤一次只处理副本集中的一个成员。
            li 当使用<code>dropDups: true</code>选项创建唯一性索引时，不能使用上述处理步骤。
            li 在版本2.6中，如果一级成员的索引是在后台创建的，则二级成员的索引创建也在后台进行。
        strong 在后台创建索引
        p 默认情况下，MongoDB在前台创建索引，该种创建方式会阻塞索引所在数据库的所有读写操作。并且，所有数据库中需要读写锁的操作都会被阻塞。
        p
            strong
                small 其他考虑
        p 后台创建索引需要耗费更长的时间，并且导致初始创建的索引结构不够紧凑，占用空间较大。随着时间的推进，
            | 通过后台方法创建的索引的结构紧凑程度可以达到通过前台方式创建的索引。
        p 当MongoDB在后台完成索引的创建后，索引在功能上和其他方式创建的索引没有区别。
        p
            strong
                small 处理步骤
        p 如果需要在后台创建索引，可以在方法<code>ensureIndex()</code>中指定<code>background: true</code>选项，如下：
        p
            code db.collection.ensureIndex({a: 1}, {background: true})
        strong 创建老格式的索引
        .alert.alert-danger 只有在MongoDB2.0之前的版本种使用。
        p MongoDB2.0版本引入了<code>{v: 1}</code>索引格式。MongoDB2.0版本和之后的版本均支持<code>{v: 1}</code>和较早的<code>{v: 0}</code>索引格式。
        p MongoDB2.0之前的版本只支持<code>{v: 0}</code>索引格式，如果需要回滚数据库到2.0之前的版本，需要重建索引。
        p 如果需要创建2.0之前版本的索引，需要首先使用<code>dropIndex()</code>方法删除索引，然后使用方法<code>ensureIndex()</code>创建索引。
            | 不能简单的重建索引。
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                p 假设将数据库从2.0版本回滚到1.8版本，并且存在如下索引：
                p
                    code { "v" : 1, "key" : { "name" : 1 }, "ns" : "mydb.items", "name" : "name_1" }
                p 为了重新创建上述索引，则首先需要删除索引：
                p
                    code db.items.dropIndex({name: 1})
                p 然后，重建<code>{v: 0}</code>格式的索引：
                p
                    code db.items.ensureIndex({name: 1}, {v: 0})
        h4#section832 8.3.2&emsp;管理索引
        p 本小节内容详述了如何管理索引，以及如何评估索引的性能。
        strong 删除索引
        p 使用方法<code>dropIndex()</code>可以删除索引。
        p
            strong
                small 删除指定索引
        p 使用方法<code>db.collection.dropIndex()</code>可以删除一个索引。
        p 例如，下例删除了集合<code>accounts</code>中<code>tax-id</code>字段上的升序索引：
        p
            code db.accounts.dropIndex({'tax-id': 1})
        p 上述操作返回如下信息：
        p
            code { "nIndexesWas" : 3, "ok" : 1 }
        p 其中，<code>nIndexesWas</code>表示执行索引删除操作之前集合中索引的总数。
        p
            strong
                small 删除所有索引
        p 使用方法<code>db.collection.dropIndexes()</code>可以删除集合中<code>_id</code>索引除外的所有索引。
        strong 修改索引
        p 如果需要修改一个已存在的索引，需要先删除、再重建索引。
        ol
            li 创建一个唯一性索引
                p 使用方法<code>ensureIndex()</code>创建一个唯一性索引：
                p
                    code db.orders.ensureIndex({'cust_id': 1, 'ord_date': -1, 'items': 1}, {unique: true})
                p 上述方法只会在索引不存在时创建新索引。
            li 尝试修改索引
                p 如果需要修改已存在的索引，不能简答的使用<code>ensureIndex()</code>方法。
                p 例如，下述语句修改了步骤1中创建的唯一性索引，去掉另外索引的唯一性约束：
                p
                    code db.orders.ensureIndex({'cust_id': 1, 'ord_date': -1, 'items': 1})
                p 上述语句会返回一个错误。
            li 删除索引
                p 首先，使用如下语句删除已存在的索引：
                p
                    code db.orders.dropIndex({'cust_id': 1, 'ord_date': -1, 'items': 1})
            li 根据需求重新创建索引
                p 然后，使用如下语句重新创建新的索引：
                p
                    code db.orders.ensureIndex({'cust_id': 1, 'ord_date': -1, 'items': 1})
        strong 重建索引
        p 如果需要重建某个集合的索引，可以使用方法<code>db.collection.reIndex()</code>，该方法在单个操作中重建集合的所有索引。
            | 该方法会删除集合上的所有索引，包括<code>_id</code>索引，然后重建删除的索引。
        p
            strong
                small 处理步骤
        p 使用如下语句重建集合索引：
        p
            code db.accounts.reIndex();
        p 当上述语句执行完成后，会返回如下的结果文档：
        p
            code {<br/>
            code.two 'nIndexesWa': 2,<br/>
            code.two 'msg': 'indexes dropped for collection',<br/>
            code.two 'nIndexes': 2,<br/>
            code.two 'indexes': [<br/>
            code.three {<br/>
            code.four 'key': {'_id': 1, 'tax-id': 1},<br/>
            code.four 'ns': 'records.accounts',<br/>
            code.four 'name': '_id_'<br/>
            code.three }<br/>
            code.two ],<br/>
            code.two 'ok': 1<br/>
            code }
        p 该方法是命令<code>reIndex</code>的包装方法，如果需要在应用程序中重建方法，请查看驱动程序的API方法。
        strong 管理创建过程中的索引
        p 可以在<code>mongo</code> shell中通过方法<code>db.currentOp()</code>查看索引创建的状态。字段<code>query、msg</code>的值意味着索引是否正在创建。
            | <code>msg</code>字段的值意味着索引完成的比例。
        p 可以在<code>mongo</code> shell中通过方法<code>db.killOp()</code>终止索引的创建。
        p 版本2.4中发生了改变：在MongoDB2.4之前，只能终止正在后台创建的索引。版本2.4之后（包含2.4版本），可以终止任何正在创建的索引，包括正在前台创建的索引。
        strong 返回索引列表
        p 在进行日常维护时，可能需要检查一个集合上的索引情况。对于集合上的每个索引，在集合<code>system.indexes</code>中都存在对应的记录，
            | 可以使用<code>db.system.indexes.find()</code>查询，或者使用<code>getIndexes()</code>方法获取某个集合上的索引。
        p
            strong
                small 查看一个集合上的索引列表
        p 使用方法<code>db.collection.getIndexes()</code>可以获得某个集合上的索引列表，如下所示：
        p
            code db.people.getIndexes()
        p
            strong
                small 查看一个数据库的索引列表
        p 为了获得某个数据库的所有索引，可以针对集合<code>system.indexes</code>进行查询，如下所示：
        p
            code db.system.indexes.find()
        strong 测量索引的使用
        p
            strong
                small 简介
        p 查询语句的性能能够很直观的反应索引的使用情况。但是，为了更深入的了解索引的使用情况，MongoDB提供了一些工具允许查看数据库中索引的使用情况。
        p
            strong
                small 操作
        ul
            li
                strong 使用方法<code>explain()</code>获取查询计划
                p 使用方法<code>explain()</code>可以获得一个查询语句的查询计划，返回结果中包含查询语句有关的统计信息，
                    | 包含索引的使用情况、遍历的文档数量，以及查询语句消耗的毫秒数。
            li
                strong 使用<code>hint()</code>控制索引的使用
                p 使用方法<code>hint()</code>可以强制查询语句使用某个索引，如下所示：
                p
                    code db.people.find( { name: "John Doe", zipcode: { $gt: "63000" } } ).hint( { zipcode: 1 } )
                p 通过结合使用方法<code>explain()</code>和<code>hint()</code>，对比不同的索引，进而得到索引的优劣。
                    | 如果在方法<code>hint()</code>中指定<code>$natural</code>选项，则指示MongoDB不适用任何索引，如下所示：
                p db.people.find( { name: "John Doe", zipcode: { $gt: "63000" } } ).hint( { $natural: 1 } )
            li
                strong 相关的报表输出
                p MongoDB提供的一些元信息相关的报表操作，可以一窥索引的相关信息：
                ul
                    li <code>serverStatus</code>的输出结果中字段：<code>indexCounters、scanned、scanAndOrder</code>
                    li <code>collStats</code>的输出结果中字段：<code>totalIndexSize、indexSizes</code>
                    li <code>dbStats</code>的输出结果中字段：<code>dbStats.indexes、dbStats.indexSize</code>
        h4#section833 8.3.3&emsp;空间索引
        p 本小节内容详细介绍了如何创建、查询<code>2d、2dsphere、haystack</code>索引。
        strong 创建2dsphere索引
        p 如果需要为GeoJSON格式的数据创建空间索引，可以使用方法<code>db.collection.ensureIndex()</code>创建<code>2dsphere</code>索引。
            | 具体用法如下所示：
        p
            code db.collection.ensureIndex({'location_field': '2dsphere'})
        p 以下处理步骤展示了如果构造GeoJSON格式的文档数据，以及如何创建2dsphere索引。
        p
            strong
                small 处理步骤
        p 首先，构造用于存储位置信息的<code>places</code>集合，其中位置信息以GeoJSON格式存储：
        p
            code db.places.insert(<br/>
            code.two {<br/>
            code.three loc : { type: "Point", coordinates: [ -73.97, 40.77 ] },<br/>
            code.three name: "Central Park",<br/>
            code.three category : "Parks"<br/>
            code.two }<br/>
            code )<br/>
            code db.places.insert(<br/>
            code.two {<br/>
            code.three loc : { type: "Point", coordinates: [ -73.88, 40.78 ] },<br/>
            code.three name: "La Guardia Airport",<br/>
            code.three category : "Airport"<br/>
            code.two }<br/>
            code )
        p 然后，在字段<code>loc</code>上创建2dsphere索引：
        p
            code db.places.ensureIndex({'loc': '2dsphere'})
        p 复合索引可以包含一个2dsphere索引键和任意非空间索引键。例如，如下实例的复合索引：
        p
            code db.places.ensureIndex({loc: '2dsphere', category: -1, name: 1})
        p 和2d索引不同，2dsphere复合索引不需要位置字段必须是复合索引中的第一个字段，如下所示：
        p
            code db.places.ensureIndex({category: 1, loc: '2dsphere'})
        p
            strong
                small 其他考虑
        p <code>geoNear</code>命令和<code>$geoNear</code>管道处理阶段要求一个集合最多只能有一个2dsphere索引和（或者）一个2d索引，
            | 但是空间查询操作符（即：<code>$near、$geoWithin</code>）允许集合拥有多个空间索引。
        p 对于<code>geoNear</code>命令和<code>$geoNear</code>管道处理阶段之所以存在上述限制，
            | 是因为<code>geoNear</code>命令和<code>$geoNear</code>管道处理阶段均不包含位置信息字段，因此，
            | 如果存在多个空间索引，则对于如何选择索引会产生混淆。
        p 而对于空间查询操作符（即：<code>$near、$geoWithin</code>），因为这些操作符均包含位置信息字段，不存在选择混淆的问题。
        p 如果需要使用<code>geoNear</code>命令和<code>$geoNear</code>管道处理阶段，请确保集合上只存在单个空间索引。
        strong 查询2dsphere索引
        p 下述示例展示了使用2dsphere索引的查询语句。
        .panel.panel-default
            .panel-heading
                strong 查询一个多边形包围的GeoJSON对象
            .panel-body
                p <code>$geoWithin</code>查询操作符用于查询位于一个GeoJSON多边形内的数据，位置信息必须以<code>GeoJSON</code>格式存储，语法如下：
                p
                    code db.collection.find({<br/>
                    code.two 'location_field': {<br/>
                    code.three $geoWithin: {<br/>
                    code.four $geometry: {<br/>
                    code.five type: 'Polygon',<br/>
                    code.five coordinates: [坐标对]<br/>
                    code.four }<br/>
                    code.three }<br/>
                    code.two }<br/>
                    code })
                p 示例程序如下：
                p
                    code db.places.find({<br/>
                    code.two 'loc': {<br/>
                    code.three $geoWithin: {<br/>
                    code.four $geometry: {<br/>
                    code.five type: 'Polygon',<br/>
                    code.five coordinates: [[[0, 0], [3, 6], [6, 1], [0, 0]]]<br/>
                    code.four }<br/>
                    code.three }<br/>
                    code.two }<br/>
                    code })
        .panel.panel-default
            .panel-heading
                strong GeoJSON对象的交集(版本2.4新特性)
            .panel-body
                p <code>$geoIntersects</code>操作符用于获取与一个指定GeoJSON对象相交的位置信息。如果相交部分不为空，
                    | 则说明与指定GeoJSON对象存在交集，交集部分包含共享边。
                p <code>$geoIntersects</code>操作符的语法如下：
                p
                    code db.collection.find({<br/>
                    code.two 'location_field': {<br/>
                    code.three $geoIntersects: {<br/>
                    code.four $geometry: {<br/>
                    code.five type: 'GeoJSON_Object_Type',<br/>
                    code.five coordinates: [坐标对]<br/>
                    code.four }<br/>
                    code.three }<br/>
                    code.two }<br/>
                    code })
                p 示例程序如下：
                p
                    code db.places.find({<br/>
                    code.two 'loc': {<br/>
                    code.three $geoIntersects: {<br/>
                    code.four $geometry: {<br/>
                    code.five type: 'Polygon',<br/>
                    code.five coordinates: [[[0, 0], [3, 6], [6, 1], [0, 0]]]<br/>
                    code.four }<br/>
                    code.three }<br/>
                    code.two }<br/>
                    code })
        .panel.panel-default
            .panel-heading
                strong 一个GeoJSON点附近的位置
            .panel-body
                p 搜附近查询用于获取一个指定坐标点附近的坐标信息，并按照距离的远近排序返回。在GeoJSON格式的数据上执行搜附近查询需要<code>2dsphere</code>索引的支持。
                p 可以使用<code>$near</code>操作符和<code>geoNear</code>命令获取一个指定GeoJSON坐标点附近的坐标信息。<code>$near</code>操作符的语法如下：
                p
                    code db.collection.find({<br/>
                    code.two 'location_field': {<br/>
                    code.three $near: {<br/>
                    code.four $geometry: {<br/>
                    code.five type: 'Point',<br/>
                    code.five coordinates: [坐标对]<br/>
                    code.four },<br/>
                    code.four $maxDistance: 最大距离（以米为单位）<br/>
                    code.three }<br/>
                    code.two }<br/>
                    code })
                p 命令<code>geoNear</code>的语法如下：
                p
                    code db.runCommand({<br/>
                    code.two geoNear: '集合名称',
                    code.two near: {<br/>
                    code.three type: 'Point',<br/>
                    code.three coordinates: [坐标对]<br/>
                    code.two },<br/>
                    code.two spherical: true<br/>
                    code })
                strong 获取球面上一个圆形内的点
                p 可以使用带有<code>$centerSphere</code>操作符的<code>$geoWithin</code>来获取一个球面上一个圆形区域的所有坐标点，
                    | 其中，<code>$centerSphere</code>操作符接受一个数组，该数组包含：
                    ul
                        li 圆形区域的中心坐标点
                        li 以弧度测量的圆半径
                p 语法如下：
                p
                    code db.collection.find({<br/>
                    code.two 'location_field': {<br/>
                    code.three $geoWithin: {<br/>
                    code.four $centerSphere: [[坐标对], 弧度半径]<br/>
                    code.three }<br/>
                    code.two }<br/>
                    code })
                p 如下示例程序获取以西经88度北纬30度为中心，10英里为半径范围内的坐标信息。其中，10英里对应的弧度半径为：10/3959（3959表示的是地球的近似半径，以英里计算）
                p
                    code db.places.find({<br/>
                    code.two 'loc': {<br/>
                    code.three $geoWithin: {<br/>
                    code.four $centerSphere: [[-88, 30], 10/3959]<br/>
                    code.three }<br/>
                    code.two }<br/>
                    code })
        strong 创建2d索引
        p 可以使用方法<code>ensureIndex()</code>创建2d索引，语法如下：
        p
            code db.collection.ensureIndex(<br/>
            code.two {<br/>
            code.three 'location_field': '2d',<br/>
            code.three 'additinal_field': 'value'<br/>
            code.two },<br/>
            code.two {<br/>
            code.three min: 坐标下限,<br/>
            code.three max: 坐标上限,<br/>
            code.three bits: 位精度<br/>
            code.two }<br/>
            code )
        p
            strong
                small 指定2d索引的经纬度范围
        p 默认情况下，2d索引的经纬度的范围为：[-180, 180)。如果文档包含的坐标信息超出上述范围，MongoDB返回错误信息。
        p 如果需要自定义经纬度的范围，可以使用<code>max、min</code>选项，如下所示：
        p
            code db.collection.ensureIndex(<br/>
            code.two {<br/>
            code.three 'location_field': '2d'<br/>
            code.two },<br/>
            code.two {<br/>
            code.three min: 坐标下限,<br/>
            code.three max: 坐标上限<br/>
            code.two }<br/>
            code )
        p
            strong
                small 指定2d索引的经纬度的精度
        p 默认情况下，使用传统坐标对的2d索引的精度为26位，大致相当于2英尺或者60厘米的精度。精度是使用<var>geohash</var>的值的位数来测量的。
            | 可以将该精度提升到32位。
        p 索引的精度并不会影响查询的精度，因为实际的经纬度坐标对总是被查询语句计算。低精度的优势是降低插入操作的负担，以及节省存储空间。
            | 高精度的优势是查询语句可以使用较少范围的索引数据返回结果集。
        p 可以使用如下语句调整索引的精度：
        p
            code db.collection.ensureIndex(<br/>
            code.two {<br/>
            code.three 'location_field': '2d'<br/>
            code.two },<br/>
            code.two {<br/>
            code.three bits: 位精度<br/>
            code.two }<br/>
            code )
        p
            strong
                small 查询2d索引
        p 下述示例展示了使用2d索引的查询语句。
        .panel.panel-default
            .panel-heading
                strong 获取平面几何上一个几何图形中的点
            .panel-body
                p 使用带有图形指定符的<code>$geoWithin</code>操作符，可以获取平面几何中一个指定图形内的坐标点信息，语法如下：
                p
                    code db.collection.find({<br/>
                    code.two 'location_field': {<br/>
                    code.three $geoWithin: {<br/>
                    code.four $box | $polygon | $center: 坐标<br/>
                    code.three }<br/>
                    code.two }<br/>
                    code })
                p 以下示例查询用于获取一个矩形中的文档记录，该矩形的左下点坐标为：[0, 0]，右上点坐标为：[100, 100]：
                p
                    code db.places.find({<br/>
                    code.two loc: {<br/>
                    code.three $geoWithin: {<br/>
                    code.four $box: [[0, 0], [100, 100]]<br/>
                    code.three }<br/>
                    code.two }<br/>
                    code })
                p 以下示例查询用于获取一个圆形中的文档记录，该圆形的圆心坐标为：[-74, 40.74]，半径为：10：
                p
                    code db.places.find({<br/>
                    code.two loc: {<br/>
                    code.three $geoWithin: {<br/>
                    code.four $center: [[-74, 40.74], 10]<br/>
                    code.three }<br/>
                    code.two }<br/>
                    code })
        .panel.panel-default
            .panel-heading
                strong 获取球面上一个圆形区域中的点
            .panel-body
                p 由于遗留数据的原因，MongoDB支持在2d索引上进行基本的球形坐标查询。通常来讲，球形计算应该使用2dsphere索引。
                p 如果需要在一个球面上查询传统坐标对的数据，需要使用带有操作符<code>$centerSphere</code>的<code>$geoWithin</code>，
                    | <code>$geoWithin</code>接受一个数组，该数组包含以下内容：
                    ul
                        li 球心的坐标
                        li 球的半径，以弧度计算。
                p 语法如下：
                p
                    code db.collection.find({<br/>
                    code.two 'location_field': {<br/>
                    code.three $geoWithin: {<br/>
                    code.four $centerSphere: [[x, y], 弧度半径]<br/>
                    code.three }<br/>
                    code.two }<br/>
                    code })
                p 下例获取以西经88度北纬30度为圆形，10英里范围内的坐标：
                p
                    code db.places.find({<br/>
                    code.two 'loc': {<br/>
                    code.three $geoWithin: {<br/>
                    code.four $centerSphere: [[-88, 30], 10/3959]<br/>
                    code.three }<br/>
                    code.two }<br/>
                    code })
        .panel.panel-default
            .panel-heading
                strong 获取平面几何中一个点附近的坐标
            .panel-body
                p 范围查询返回距离指定坐标点最近的100个坐标对，并且按照距离远近排序返回，使用<code>$near</code>操作符或者<code>geoNear</code>命令，
                    | 但是都需要一个2d索引；语法如下：
                p
                    code db.collection.find({<br/>
                    code.two 'location_field': {<br/>
                    code.three $near: [x, y]<br/>
                    code.two }<br/>
                    code })
                p <code>geoNear</code>命令的语法为：
                p
                    code db.runCommand( { geoNear: <collection>, near: [ x , y ] } )
        .panel.panel-default
            .panel-heading
                strong 精确匹配平面几何中的位置
            .panel-body
                p 版本2.6中发生了改变：在之前的版本中，2d索引支持坐标对的精确匹配。
                p 不能使用2d索引返回精确匹配的坐标对，使用普通的升序/降序索引完成坐标对的精确匹配。
                p 在下例中，<code>find()</code>方法，如果存在索引<code>{'loc': 1}</code>，可以返回一个精确匹配的索引：
                p
                    code db.collection.find({loc: [x, y]})
                p 上述查询会返回任何包含<code>[x, y]</code>的文档。
        strong 创建Haystack索引
        p 一个haystack索引必须关联两个字段：位置信息字段和第二个字段，第二个字段用于精确匹配。Haystack索引依据位置信息和附加的一个过滤条件返回结果文档。
            | 这些索引并不一定适合用于获取距离一个指定位置最近的文档。
        p 使用如下语法创建haystack索引：
        p
            code db.collection.ensureIndex(<br/>
            code.two {<br/>
            code.three 'location_field': 'geoHaystack',<br/>
            code.three 'additinal_field': 1,<br/>
            code.two },<br/>
            code.two {bucketSize: bucket_value}<br/>
            code )
        p 创建haystack索引时，必须指定<code>bucketSize</code>选项。
            | 一个<code>bucketSize</code>值为5的haystack索引会将与某个特定位置的经度，纬度相差5个单位以内的所有位置都放在同一个区域组内。
            | <code>bucketSize</code>决定了索引的粒度。可以调整这个参数以适应数据分布，这样查询在通常情况下将只需要搜索非常小的区域。
            | 由<code>bucketSize</code>确定的区域是可以互相覆盖的，单个文档可以出现在多个bucket中。
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                p 如果某个集合包含如下结构的文档：
                p
                    code { _id : 100, pos: { lng : 126.9, lat : 35.2 } , type : "restaurant"}<br/>
                    code { _id : 200, pos: { lng : 127.5, lat : 36.1 } , type : "restaurant"}<br/>
                    code { _id : 300, pos: { lng : 128.0, lat : 36.7 } , type : "national park"}
                p 如下语句将会创建一个haystack索引，该索引的每个bucket存储键值的经度或维度相差1个单位。
                p
                    code db.places.ensureIndex( { pos : "geoHaystack", type : 1 } , { bucketSize : 1 } )
                p 上述语句创建的索引中，<code>_id</code>值为<code>200</code>的文档在两个bucket中都存在相应的索引条目：
                    ul
                        li 包含<code>_id</code>值为<code>100</code>的文档的bucket
                        li 包含<code>_id</code>值为<code>300</code>的文档的bucket
        p 可以通过<code>geoSearch</code>命令使用haystack索引。
        p 默认情况下，使用haystack索引的查询语句返回50个匹配的文档。
        p
            strong
                small 查询haystack索引
        p haystack索引是经过优化的特殊2d空间索引，用于返回较小范围的结果集。
        p 可以使用<code>geoSearch</code>命令查询haystack索引，查询时，必须指定位置字段和额外的第二个匹配字段。例如：
            | 为了获取<code>type</code>字段值为<code>restaurant</code>，并且在指定坐标附近的文档，可以使用如下语句：
        p
            code db.runCommand( { geoSearch : "places" , search : { type: "restaurant" } , near : [-74, 40.74] , maxDistance : 10 } )
        .alert.alert-danger Haystack索引不适合用于获取指定坐标附近所有位置的查询。最近点的距离有可能会大于bucketsize。
            p haystack索引不支持球面查询。方法<code>find()</code>和<code>geoNear</code>命令不能使用haystack索引。
        strong 计算球面几何上坐标的距离
        .alert.alert-info 虽然2d索引支持球面距离的计算，但是如果数据都是经纬度坐标对，可以考虑将2d索引转换成2dsphere索引。
        p 2d索引支持在平面几何计算距离的查询，同时支持使用如下方法和命令在球面几何上计算距离：
            ul
                li
                    code $nearSphere
                li
                    code $centerSphere
                li
                    code $near
                li  带有选项<code>{spherical: true}</code>的<code>geoNear</code>命令
        .alert.alert-danger
            p 上述三个查询操作符使用弧度距离进行计算，其他的查询操作符不是。
            p 为了使球面查询操作符的计算结果正确，必须将距离转换为弧度距离进行计算，然后将弧度距离转换为应用程序使用的距离单位。
            p 转换规则：
                ul
                    li
                        strong 距离到弧度
                        p 用距离除以球面的半径（即：地球的半径），两者的单位必须保持一致
                    li
                        strong 弧度到距离
                        p 用弧度乘以球面的半径（即：地球的半径），其中球面半径的单位取决于应用程序需要的单位
            p 地球的半径近似值为：3959英里，或者6371千米。
        p 下述查询语句返回集合<code>places</code>中以<code>[-74, 40.74]</code>为圆心，100英里为半径范围内的文档：
        p
            code db.places.find({<br/>
            code.two 'loc': {<br/>
            code.three $geoWithin: {<br/>
            code.four $centerSphere: [[-74, 40.74], 100/3959]<br/>
            code.three }<br/>
            code.two }<br/>
            code })
        p 可以使用带有<code>distanceMultiplier</code>选项的<code>geoNear</code>命令在<code>mongod</code>中自动完成距离到弧度的转换，
            | 而不需要在应用程序中手动转换。
        p 下例球面查询返回集合<code>places</code>中以<code>[-74, 40.74]</code>为圆心，100英里为半径范围内的文档：
        p
            code db.runCommand({geoNear: 'places', near: [-74, 40.74], spherical: true})
        p 上述命令的返回结果可能为：
        p
            code {<br/>
            code.two // [...]<br/>
            code.two 'results': [<br/>
            code.three {<br/>
            code.four 'dis': 0.01853688938212826,<br/>
            code.four 'obj': {<br/>
            code.five '_id': ObjectId(...),<br/>
            code.five 'loc': [-73, 40]<br/>
            code.four }<br/>
            code.three }<br/>
            code.two ],<br/>
            code.two 'stats': {<br/>
            code.three // [...]<br/>
            code.three 'avgDistance': 0.01853688938212826,<br/>
            code.three 'maxDistance': 0.01853714811400047<br/>
            code.two },<br/>
            code.two 'ok': 1<br/>
            code }
        .alert.alert-danger 球面查询中的条件如果环绕着南/北极或者在-180到180经度的交界过渡区，会导致错误。
        .alert.alert-info 虽然空间索引默认的类地球球面边界是大于等于-180到小于180间，纬度的合理值却是在-90到90间。
        p
            strong
                small 距离系数
        p 带有<code>distanceMultiplier</code>选项的<code>geoNear</code>命令可以在将结果和给定值相乘后再返回。
            | 这可以让MongoDB返回转换后的值，避免了在应用逻辑中转换单位的需要。
        p 在球面查询中使用<code>distanceMultiplier</code>选项会返回和<code>geoNear</code>命令相同的结果，
            | 都不需要进行弧度到距离的转换。
            | 如下示例中，在<code>geoNear</code>命令中使用<code>distanceMultiplier、spherical</code>选项：
        p
            code db.runCommand( { <br/>
            code.two geoNear: "places",<br/>
            code.two near: [ -74, 40.74 ],<br/>
            code.two spherical: true,<br/>
            code.two distanceMultiplier: 3959<br/>
            code } )
        p 上述命令的返回结果可能为：
        p
            code {<br/>
            code.two // [...]<br/>
            code.two 'results': [<br/>
            code.three {<br/>
            code.four 'dis': 0.01853688938212826,<br/>
            code.four 'obj': {<br/>
            code.five '_id': ObjectId(...),<br/>
            code.five 'loc': [-73, 40]<br/>
            code.four }<br/>
            code.three }<br/>
            code.two ],<br/>
            code.two 'stats': {<br/>
            code.three // [...]<br/>
            code.three 'avgDistance': 0.01853688938212826,<br/>
            code.three 'maxDistance': 0.01853714811400047<br/>
            code.two },<br/>
            code.two 'ok': 1<br/>
            code }
        h4#section834 8.3.4&emsp;文本搜索索引
        p 翻译中。。。
        h4#section835 8.3.5&emsp;索引策略
        p 为应用程序建立索引时需要考虑多方面的因素，包括常用查询的类型，应用程序的读写比例，以及操作系统的可用内存量。
        p 当制定索引策略时，必须对应用程序用到的查询语句进行深入分析。在建立索引之前，列出应用程序中使用到的查询语句，交叉对比这些查询语句，
            | 然后在最频繁的查询字段上创建合适的索引。虽然索引对数据库的写操作存在副作用，但是相对于大数据量的常用查询而言，会明显提高这些查询语句的性能，
            | 所以，相对于写操作，查询语句性能的提升还是值得的。总而言之，在创建索引之前，需要充分分析应用程序的常用查询语句，
            | 以使建立的索引能够最大程度的满足。
        p 建立索引的最优策略是通过分析查询语句，先列出不同的索引建立清单，然后在相同的数据集上通过对比这些不同索引的实际运行效果，
            | 最终决定使用最优的索引。另外，在应用程序的运行周期内，需要定期检测索引的使用情况，如果发现索引不再适合查询语句，需要及时调整，
            | 如果发现有些索引不再被查询语句引用，应该及时删除相应的索引。
        p MongoDB可以使用单个索引支持多个给定的操作，但是，每个<code>$or</code>查询子句可能会使用不同的索引。
        strong 创建索引以支持查询语句
        p 当索引包含查询语句需要遍历的所有字段时，查询语句执行时可以引用该索引，此时，查询语句通过遍历索引条目获取结果，而不是通过遍历集合获取结果。
            | 创建可以被查询引用的索引能够大幅度的提高查询语句的性能。
        p 本小节内容详述了创建可以被查询语句引用的索引的策略。
        p
            strong
                small 如果所有的查询语句使用相同的查询字段，则创建对应的单个字段的索引
        p 如果应用程序只是查询单个集合的某个字段，此时可以在查询字段上创建大个字段的索引以满足查询语句。例如，
            | 应用程序的查询语句频繁的在集合<code>products</code>的文档字段<code>category</code>上进行查询，此时可以通过如下语句创建索引：
        p
            code db.products.ensureIndex({'category': 1})
        p
            strong
                small 创建复合索引以支持不同的查询语句
        p 如果查询语句有时查询某个字段，有时查询该字段和其他字段的组合，此时，应该创建复合索引，而不是创建独立的单个字段的索引，
            | MongoDB会对上述的两个查询语句都引用该复合索引。例如：应用程序可能在集合<code>products</code>的<code>category、item</code>上创建复合索引：
        p
            code db.products.ensureInde({'category': 1, 'item': 1})
        p 对于上述索引，针对字段<code>category</code>的查询，以及针对字段<code>category、item</code>的查询，均可以使用该索引。
            | 如果查询语句的查询字段是复合索引的前置字段，则查询语句就可以引用该复合索引。
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                p 假设集合上存在如下索引：
                p
                    code {x: 1, y: 1, z: 1}
                p 则上述索引可以支持以下字段的查询：
                p
                    code {x: 1}<br/>
                    code {x: 1, y: 1}<br/>
                    code {x: 1, y: 1, z: 1}
                p 在某些场景种，复合索引的前值索引可以提供更好的查询性能：例如，假设<code>z</code>字段存储的是一个很大的数组。
                p 同时，索引<code>{x: 1, y: 1, z: 1}</code>也可以支持引用索引<code>{x: 1, z: 1}</code>的查询。
                p 另外，索引<code>{x: 1, z: 1}</code>有其他的用处，比如：
                p
                    code db.collection.find( { x: 5 } ).sort( { z: 1} )
                p 对于上述查询语句，索引<code>{x: 1, z: 1}</code>可以同时满足查询和排序，但是索引<code>{x: 1, y: 1, z: 1}</code>只能满足查询。
        p 从MongoDB版本2.6开始，MongoDB可以使用索引的交叉引用来满足查询，选择使用复合索引，还是选择使用索引的交叉引用，取决于系统的要求。
        p
            strong
                small 创建支持Covered查询的索引
        p 一个Covered查询指的是该查询语句包括：
            ul
                li 所有的查询字段（即：过滤条件中使用到的字段）均包含在该索引中
                li 所有的返回字段（即：返回结果集中包含的字段）均包含在该索引中
        p 由于索引字段覆盖了查询使用到的字段，所以，MongoDB可以只通过索引完成查询条件的匹配和结果集的返回，而不需要遍历索引关联的文档集合，
            | 即：MongoDB可以只通过索引得到最终的查询结果。
        p 相较于查询文档集合，只查询索引的速度要快得多，因为，通常来讲，索引键对较小，并且索引通常是内存可用的，或者是在磁盘上连续存储的。
        p 对于一个Covered查询，MongoDB会自动使用相关的索引满足查询。为了确保一个索引可以覆盖（cover）一个查询语句，
            | 则需要创建一个包含所有查询文档的字段和结果集中的字段索引。可以同时投影操作指定结果集需要返回的字段，默认时，MongoDB会返回<code>_id</code>字段，
            | 所以，如果索引不包含<code>_id</code>字段，需要在投影操作中显式的排除<code>_id</code>字段。
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                p 假设集合<code>users</code>上存在以下复合索引：
                p
                    code db.users.ensureIndex({status: 1, user: 1})
                p 对于如下查询语句，上述所以会覆盖该查询语句：
                p
                    code db.users.find({status: 'A'}, {user: 1, _id: 0})
                p 在上述查询语句中，投影操作显式的将<code>_id</code>字段从结果集中排除，因为索引中只包含<code>status、user</code>字段。
                p 如果查询语句没有显式的排除<code>_id</code>字段，查询语句默认返回该字段，此时，上述索引没有覆盖该查询语句，如下：
                p
                    code db.users.find({status: 'A'}, {user: 1})
        p 如果出现以下情况，一个索引不能覆盖一个查询语句：
            ul
                li 集合文档的索引字段包含一个数组。如果一个索引字段是数组类型，则该索引成为多键索引，多键索引不能覆盖查询。
                li 集合文档的索引字段包含嵌套文档。如果需要为嵌套文档的字段创建索引，使用点符号（.）。例如，假设集合<code>users</code>中的文档结构如下：
                    p
                        code {_id: 1, user: {login: 'tester'}}
                    p 该集合上存在如下索引:
                    p
                        code {user: 1}<br/>
                        code {'user.login': 1}
                    p 索引<code>{user: 1}</code>可以覆盖以下查询：
                    p
                        code db.users.find( { user: { login: "tester" } }, { user: 1, _id: 0 } )
                    p 但是，索引<code>{'user.login': 1}</code>不能覆盖以下查询：
                    p
                        code db.users.find( { "user.login": "tester" }, { "user.login": 1, _id: 0 } )
                    p 但是，上述查询语句使用索引<code>{'user.login': 1}</code>进行结果集的匹配
        p 可以通过方法<code>explain()</code>查看一个查询语句是否一个Covered查询语句。如果方法<code>explain()</code>返回字段<code>indexOnly</code>值为<code>true</code>，
            | 则说明该查询语句是一个Covered查询。
        strong 使用索引返回排序结果集
        p 在MongoDB中，排序操作可以通过有序的索引条目完成。如果查询语句不能通过索引获取排序结果集，则会在内存中对结果集进行单独的排序操作。
            | 使用索引的排序操作通常来讲要比不使用索引的排序操作更高效。另外，对于不使用索引的排序操作，如果内存的使用量超过32M，排序操作会终止。
        p
            strong
                small 使用单一字段索引排序
        p 如果在一个字段上存在一个升序或降序的索引，则通过索引可以在该字段上进行升序和降序两个方向的排序操作。
        p 例如，在集合<code>records</code>的<code>a</code>字段上存在如下索引：
        p
            code db.records.ensureIndex({a: 1})
        p 则上述索引可以支持如下的排序操作
        p
            code db.records.find().sort({a: 1})<br/>
            code db.records.find().sort({a: -1})
        p
            strong
                small 多个字段上的排序操作
        p 通过复合索引可以支持多个字段上的排序操作。
        p 可以针对复合索引的全部字段或部分字段进行排序；但是，排序字段的顺序必须和索引中声明的顺序相同。例如，
            | 索引<code>{a: 1, b: 1}</code>支持<code>{a: 1, b: 1}</code>的排序，但是不支持<code>{b: 1, a: 1}</code>的排序。
        p 对于使用索引的排序操作，必须保证排序字段的顺序和索引声明中字段的顺序一致，或者，排序字段的顺序和索引声明中字段的顺序正好相反。
            | 例如，索引<code>{a: 1, b: 1}</code>支持<code>{a: 1, b: 1}</code>和<code>{a: -1, b: -1}</code>的排序，
            | 但是不支持<code>{a: -1, b: 1}</code>的排序。
        ul
            li
                strong
                    small 排序和复合索引的前置字段
                p 如果排序字段是完整的索引字段，或者是索引的前置字段，则MongoDB可以使用索引完成排序操作。索引的前置字段指的是：
                    | 索引开始处的一个或多个索引字段。
                p 例如，在集合<code>data</code>上存在如下的复合索引：
                p
                    code db.data.ensureIndex({a: 1, b: 1, c: 1, d: 1})
                p 则如下字段均是上述索引的前置字段：
                p
                    code {a: 1}<br/>
                    code {a: 1, b: 1}<br/>
                    code {a: 1, b: 1, c: 1}
                p 如下表格中的查询语句可以利用索引完成结果集的排序操作，而不需要在内存中针对结果集进行额外的排序操作：
                .table-responsive
                    table.table.table-bordered
                        thead
                            tr
                                th(width='70%') 查询语句
                                th 使用的前缀索引
                        tbody
                            tr
                                td
                                    code db.data.find().sort({a: 1})
                                td
                                    code {a: 1}
                            tr
                                td
                                    code db.data.find().sort({a: -1})
                                td
                                    code {a: 1}
                            tr
                                td
                                    code db.data.find().sort({a: 1, b: 1})
                                td
                                    code {a: 1, b: 1}
                            tr
                                td
                                    code db.data.find().sort({a: -1, b: -1})
                                td
                                    code {a: 1, b: 1}
                            tr
                                td
                                    code db.data.find().sort({a: 1, b: 1, c: 1})
                                td
                                    code {a: 1, b: 1, c: 1}
                            tr
                                td
                                    code db.data.find({a: {$gt: 4}}).sort({a: 1, b: 1})
                                td
                                    code {a: 1, b: 1}
                p 考虑如下查询语句，索引字段存在于查询语句的过滤条件和排序字段中：
                p
                    code db.data.find({a: {$gt: 4}}).sort({a: 1, b: 1})
                p 在上述查询语句中，MongoDB可以使用索引按照排序语句的顺序获取结果文档集。如上例所示，
                    | 过滤条件中的索引前缀可能不同于排序语句中的索引前缀。
            li
                strong 排序和复合索引的非前置字段
                p 复合索引支持在非前值字段上的排序操作。如果想要实现该效果，则查询语句中的过滤条件必须包含所有排序字段之前的索引字段的相等性过滤条件。
                p 例如，假设集合<code>data</code>上存在如下索引：
                p
                    code {a: 1, b: 1, c: 1, d: 1}
                p 则如下表格中的查询语句可以使用上述索引完成排序操作：
                .table-responsive
                    table.table.table-bordered
                        thead
                            tr
                                th(width='70%') 查询语句
                                th 使用的前缀索引
                        tbody
                            tr
                                td
                                    code db.data.find({a: 5}).sort({b: 1, c: 1})
                                td
                                    code {a: 1, b: 1, c: 1}
                            tr
                                td
                                    code db.data.find({b: 3, a: 4}).sort({c: 1})
                                td
                                    code {a: 1, b: 1, c: 1}
                            tr
                                td
                                    code db.data.find({d: 5, b: {$lt: 3}}).sort({b: 1})
                                td
                                    code {a: 1, b: 1}
                p 在上述最后一个查询语句中，只有排序字段（b）前的索引字段（a）必须存在相等性过滤条件，其他的索引字段可用于指定其他过滤条件。
                p 如果查询语句没有指定排序字段前索引字段的相等性条件，则该查询语句不能高效的使用复合索引。例如，
                    | 下例查询语句中指定了排序语句<code>{c: 1}</code>，但是查询语句的过滤条件中并没有指定<code>c</code>字段前的<code>a、b</code>字段的相等性过滤条件：
                p
                    code db.data.find({a: {$gt: 2}}).sort({c: 1})<br/>
                    code db.data.find({c: 5}).sort({c: 1})
                p 上述两个查询语句不能高效的使用复合索引<code>{a: 1, b: 1, c: 1, d: 1}</code>，甚至不会使用该索引获取结果文档。
        strong 确保索引位于内存中
        p 为了更快速的处理，请确保索引数据完全处于内存中，这样可以避免索引的磁盘读取。
        p 使用帮助方法<code>db.collection.totalIndexSize()</code>可以获取某个集合上索引的总大小（返回结果以字节为单位）：
        p
            code > db.collection.totalIndexSize()<br/>
            code 4294976499
        p 上例中，索引的大小为4.3G。为了确保索引完全位于内存中，不但需要确保索引的可用内存量，并且需要确保工作区间中其他部分数据在内存中的空间消耗，
            | 并且，需要谨记：如果拥有多个集合，必须考虑到所有集合中索引的空间消耗，索引和工作区间必须能够同时位于内存中。
        p
            strong
                small 只保存最近数据在内存中的索引
        p 并不是所有的场景中都需要索引完全位于内存中。如果索引字段的值随着插入操作的进行持续增加，并且应用程序的大部分查询语句只需要获取最近新增的文档，
            | 此时，MongoDB只需要在内存中存储需要经常访问文档的索引即可，这样可以高效的使用索引，并且最小化索引消耗的内存量。
        strong 创建具有选择性的查询
        p 选择性指的是查询语句使用索引缩窄结果集的能力。高效的索引通常都是具有较高的选择性，这样可以使MongoDB使用索引完成匹配查询语句的大部分工作。
        p 为了确保选择性，在编写查询语句时，需要限制索引字段关联的文档数量。创建具有合适选择性的查询语句与索引数据有关。
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                p 假设存在字段<code>status</code>，该字段的可能值为<code>new、processed</code>。如果在该字段上创建索引，
                    | 则该索引具有较低的选择性，在定位文档时该索引的用处很弱。
                p 相对上述索引更好的选择是，将较低选择性的字段和其他字段组合起来创建一个复合索引。比如，在字段<code>status、created_at</code>上创建复合索引。
                    | 或者，根据具体的场景，可以将不同<code>status</code>的值分别存储在独立的集合中。
        .panel.panel-default
            .panel-heading 示例
            .panel-body
                p 假设集合上存在索引<code>{a: 1}</code>，并且<code>a</code>字段的可能取值有三个：
                p
                    code { _id: ObjectId(), a: 1, b: "ab" }<br/>
                    code { _id: ObjectId(), a: 1, b: "cd" }<br/>
                    code { _id: ObjectId(), a: 1, b: "ef" }<br/>
                    code { _id: ObjectId(), a: 2, b: "jk" }<br/>
                    code { _id: ObjectId(), a: 2, b: "lm" }<br/>
                    code { _id: ObjectId(), a: 2, b: "no" }<br/>
                    code { _id: ObjectId(), a: 3, b: "pq" }<br/>
                    code { _id: ObjectId(), a: 3, b: "rs" }<br/>
                    code { _id: ObjectId(), a: 3, b: "tv" }
                p 如果需要查询<code>{a: 1, b: 'no'}</code>，则MongoDB需要遍历3个集合文档来获取单个结果文档。相似的，
                    | 如果需要查询<code>{a: {$gt: 1}, b: 'tv'}</code>，则MongoDB需要遍历6个集合文档，最终得到一个结果文档。
                p 考虑如下的集合文档，该集合中<code>a</code>字段拥有9个不同的值：
                p
                    code { _id: ObjectId(), a: 1, b: "ab" }<br/>
                    code { _id: ObjectId(), a: 2, b: "cd" }<br/>
                    code { _id: ObjectId(), a: 3, b: "ef" }<br/>
                    code { _id: ObjectId(), a: 4, b: "jk" }<br/>
                    code { _id: ObjectId(), a: 5, b: "lm" }<br/>
                    code { _id: ObjectId(), a: 6, b: "no" }<br/>
                    code { _id: ObjectId(), a: 7, b: "pq" }<br/>
                    code { _id: ObjectId(), a: 8, b: "rs" }<br/>
                    code { _id: ObjectId(), a: 9, b: "tv" }
                p 如果查询<code>{a: 2, b: 'cd'}</code>，MongoDB只需要遍历一个文档就可获取结果文档。该索引和查询语句具有较高的选择性，
                    | 因为<code>a</code>字段具有较多的不同值（分布的较为均匀）。
                p 但是，虽然针对上述集合，索引具有较高的选择性，但是如果需要查询<code>{a: {$gt: 5}, b: 'tv'}</code>，MongoDB仍然需要遍历4个文档。
        p 如果数据的总体选择性较低，并且MongoDB需要读取一定量的数据用于返回结果集，此时，某些查询语句不适用索引可能更高效，
            | 需要实际的测试（即：参考<code>explain()</code>方法的返回结果）。
